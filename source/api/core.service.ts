/**
 * REST API for Flexicore filtered by your access rights
 * Flexicore REST API
 *
 * OpenAPI spec version: V1.1.0
 * Contact: avishaybennatan@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'; import { FlexiCoreDecycle } from './flexiCoreDecycle';

import { Observable } from 'rxjs/Observable';

import { Baseclass } from '../model/baseclass';
import { Baselink } from '../model/baselink';
import { BasicContainer } from '../model/basicContainer';
import { Category } from '../model/category';
import { Clazz } from '../model/clazz';
import { ClazzLinkContainer } from '../model/clazzLinkContainer';
import { FileResource } from '../model/fileResource';
import { FileType } from '../model/fileType';
import { FilteringInformationHolder } from '../model/filteringInformationHolder';
import { Job } from '../model/job';
import { LicenseRequest } from '../model/licenseRequest';
import { LicensingFeature } from '../model/licensingFeature';
import { LicensingProduct } from '../model/licensingProduct';
import { LinkContainer } from '../model/linkContainer';
import { NewUser } from '../model/newUser';
import { NewUserUserClass } from '../model/newUserUserClass';
import { Operation } from '../model/operation';
import { PluginInformationHolder } from '../model/pluginInformationHolder';
import { Role } from '../model/role';
import { RoleToUser } from '../model/roleToUser';
import { RoleUserContainer } from '../model/roleUserContainer';
import { RunningUser } from '../model/runningUser';
import { Tenant } from '../model/tenant';
import { UIComponent } from '../model/uIComponent';
import { UIComponentsRegistrationContainer } from '../model/uIComponentsRegistrationContainer';
import { UserClass } from '../model/userClass';
import { View } from '../model/view';

import { BASE_PATH, COLLECTION_FORMATS } from '../variables';
import { Configuration } from '../configuration';
import { HttpClient, HttpEvent, HttpHeaders, HttpRequest, HttpResponse } from '@angular/common/http';


@Injectable()
export class CoreService {

    protected basePath = 'https://192.168.0.41:8080/FlexiCore/rest';
    public defaultHeaders = new HttpHeaders();
    public configuration: Configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * 
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    private extendObj<T1, T2>(objA: T1, objB: T2) {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                (objA as any)[key] = (objB as any)[key];
            }
        }
        return <T1 & T2>objA;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    /**
     * 
     * @param roleId 
     * @param userId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public addUserToRole(roleId: string, userId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.addUserToRoleWithHttpInfo(roleId, userId, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param id 
     * @param crtId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public attachCertificate(id: string, crtId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.attachCertificateWithHttpInfo(id, crtId, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public attachTenant(authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.attachTenantWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * 
     */
    public checkDBAvailable(extraHttpRequestParams?: any): Observable<boolean> {
        return this.checkDBAvailableWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Connect a Category to an instance of any entity in the system
     * @summary Connect to Category
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param catId The ID of an existing Category
     */
    public connectCategory(baseId: string, authenticationkey?: string, catId?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.connectCategoryWithHttpInfo(baseId, authenticationkey, catId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public connectToTenant(authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.connectToTenantWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param type 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public count(type: string, authenticationkey?: string, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<number> {
        return this.countWithHttpInfo(type, authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public countAllofType(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<number> {
        return this.countAllofTypeWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public countConnected(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<number> {
        return this.countConnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public countDisconnected(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<number> {
        return this.countDisconnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * Creates a link between two instances in a generic way, provide values of the link
     * @summary Create a link
     * @param leftId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param rightId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value The ID of any instance inheriting from FC Baseclass, this effectively creates a triple link
     * @param simpleValue An explicit value of a string that can be part of the link
     * @param check If true, check if the link with these Left, Right and Complex Value values exists, if yes, then it will not be created
     */
    public createBaselink(leftId: string, rightId: string, linkClazzName: string, authenticationkey?: string, value?: string, simpleValue?: string, check?: boolean, extraHttpRequestParams?: any): Observable<Baselink> {
        return this.createBaselinkWithHttpInfo(leftId, rightId, linkClazzName, authenticationkey, value, simpleValue, check, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Return a single category
     * @summary Create a Category
     * @param categoryName Inside a user interface categories are displayed by thier name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public createCategory(categoryName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Category> {
        return this.createCategoryWithHttpInfo(categoryName, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public createRole(authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Role> {
        return this.createRoleWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * 
     * @param tenantName 
     * @param apiKey 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public createTenant(tenantName: string, apiKey: string, authenticationkey?: string, body?: NewUser, extraHttpRequestParams?: any): Observable<Tenant> {
        return this.createTenantWithHttpInfo(tenantName, apiKey, authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param tenantName 
     * @param apiKey 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public createTenantNoUser(tenantName: string, apiKey: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Tenant> {
        return this.createTenantNoUserWithHttpInfo(tenantName, apiKey, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param loginuponsuccess 
     * @param body 
     */
    public createUser(authenticationkey?: string, loginuponsuccess?: boolean, body?: NewUserUserClass, extraHttpRequestParams?: any): Observable<RunningUser> {
        return this.createUserWithHttpInfo(authenticationkey, loginuponsuccess, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }



    /**
     * deletes an entity by id
     * @summary delete
     * @param id The id of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteById(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteByIdWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * deletes an entity by id
     * @summary delete
     * @param id The id of the instance to be deleted
     * @param className The type of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteById_2(id: string, className: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteById_2WithHttpInfo(id, className, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param md5 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteFileResource(md5: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteFileResourceWithHttpInfo(md5, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * delete heap dump
     * @summary deleteHeapDump
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteHeapDump(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.deleteHeapDumpWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteMedia(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteMediaWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Remove an existing link by the ID of its 'sides'
     * @summary Remove a link
     * @param leftId The ID of the left side of the link
     * @param rightId The ID of the right side of the link
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public detachEntities(leftId: string, rightId: string, linkClazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.detachEntitiesWithHttpInfo(leftId, rightId, linkClazzName, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * Disable a previously disabled Category, the CategoryID to be enabled is passed as the entity in the Post request(!)
     * @summary Disable Category on Class
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.User&#39; 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public disableCategory(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.disableCategoryWithHttpInfo(className, authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Disconnect a Category from an instance of a connected(to this Category) entity in the system
     * @summary Disconnect from Category
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass and connected to the specified Category
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param catId The ID of an existing Category
     */
    public disconnectCategory(baseId: string, authenticationkey?: string, catId?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.disconnectCategoryWithHttpInfo(baseId, authenticationkey, catId, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param id id of the FileResource Object to Download
     */
    public download(authenticationkey: string, id: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.downloadWithHttpInfo(authenticationkey, id, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * duplicate an entity by Id , returns null if not successfully duplicated
     * @summary duplicate an entity, shallow by id 
     * @param id The ID of the entity required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public duplicate(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Baseclass> {
        return this.duplicateWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * Before a Category can be connected to an INSTANCE of a class it must be enabled to the class, thus a list of categories can be easily filtered by the context of the class at hand, the CategoryID to be enabled is passed as the entity in the Post request(!)
     * @summary Enable Category on Class
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.User&#39; 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public enableCategory(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.enableCategoryWithHttpInfo(className, authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * exports to file 
     * @summary export baseclass
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public exportBaseclass(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.exportBaseclassWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public fileResourcesOfType(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Array<FileResource>> {
        return this.fileResourcesOfTypeWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * finalize FileResource , sending it for processing
     * @summary finalize
     * @param md5 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param hint 
     * @param fileType 
     * @param dontProcess 
     */
    public finalizeUpload(md5: string, authenticationkey?: string, hint?: string, fileType?: string, dontProcess?: boolean, extraHttpRequestParams?: any): Observable<Job> {
        return this.finalizeUploadWithHttpInfo(md5, authenticationkey, hint, fileType, dontProcess, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Find an entity by Id and type, returns null if not found
     * @summary find entity by id and class
     * @param id The ID of the entity required
     * @param classname The canonical classname of the required entity
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findById(id: string, classname: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Baseclass> {
        return this.findByIdWithHttpInfo(id, classname, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Find an instance of a Baseclass extender by its id, returns an instance of a Baseclass
     * @summary Find an instance by ID
     * @param ID The id of instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findById_3(ID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Baseclass> {
        return this.findById_3WithHttpInfo(ID, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findById_4(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Role> {
        return this.findById_4WithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * returns a list of instances of the type requested
     * @summary Find an instance by its name
     * @param name The name of instance to be found
     * @param classname The cannonical classname of the instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findByName(name: string, classname: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.findByNameWithHttpInfo(name, classname, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     */
    public findBySidesId(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.findBySidesIdWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinks(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Baselink>> {
        return this.findLinksWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksContainers(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<LinkContainer>> {
        return this.findLinksContainersWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksValues(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.findLinksValuesWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param clientType 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view 
     */
    public generateClient(clientType: string, authenticationkey?: string, view?: string, extraHttpRequestParams?: any): Observable<Job> {
        return this.generateClientWithHttpInfo(clientType, authenticationkey, view, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }



    /**
     * Get a list of all Categories whose name starts with the supplied string
     * @summary Get a list of Categories  by name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getAllCategories(authenticationkey?: string, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Category>> {
        return this.getAllCategoriesWithHttpInfo(authenticationkey, pagesize, currentpage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Get a list of all Categories that are connected to an instance
     * @summary List Categories  by Instance
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllCategoriesConnected(baseId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.getAllCategoriesConnectedWithHttpInfo(baseId, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllFileTypes(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<FileType>> {
        return this.getAllFileTypesWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Get a list of all Operations defined for the this Class, Some Operations have meaning with some Classes only
     * @summary Get all Operations
     * @param clazzName The canonical classname of the link required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllOperations(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Operation>> {
        return this.getAllOperationsWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * Returns a list of ClazzLinkContainer instances of the given link(!) canonical name
     * @summary Get a list of all associations 
     * @param clazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAssociations(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<ClazzLinkContainer>> {
        return this.getAssociationsWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Get a list of all Categories that can be used (previously enabled) by a Class
     * @summary List Categories  by Class
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.media.Media&#39; will retrieve only Categories that can be used with a Media Object(Instance)
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getCategory(className: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Category>> {
        return this.getCategoryWithHttpInfo(className, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Get a list of all Categories whose name starts with the supplied string
     * @summary Get a list of Categories  by name
     * @param name A string that must match the left characters of a retrieved Category name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getCategoryByName(name: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Category>> {
        return this.getCategoryByNameWithHttpInfo(name, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Return a concrete instance of type Clazz, every type in the system including those created by Plug-ins have a concrete instance of Clazz type describing it.
     * @summary Get a Clazz instance from a canonical name
     * @param clazzName The canonical classname for which the instance is required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getClazz(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Clazz> {
        return this.getClazzWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getClients(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.getClientsWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getConnected(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.getConnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param id 
     * @param wantedClazzName 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getDisconnected(id: string, wantedClazzName: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.getDisconnectedWithHttpInfo(id, wantedClazzName, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }



    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public getFeatures(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Array<LicensingFeature>> {
        return this.getFeaturesWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * 
     * @param md5 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getFileResource(md5: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.getFileResourceWithHttpInfo(md5, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param jobID 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getJob(jobID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Job> {
        return this.getJobWithHttpInfo(jobID, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }





    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view 
     */
    public getSwaggerJSON(authenticationkey: string, view?: string, extraHttpRequestParams?: any): Observable<string> {
        return this.getSwaggerJSONWithHttpInfo(authenticationkey, view, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param apiKey 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getTenant(apiKey: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Tenant> {
        return this.getTenantWithHttpInfo(apiKey, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getTenants(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Tenant>> {
        return this.getTenantsWithHttpInfo(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * import baseclass
     * @summary import baseclass
     * @param className 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public importBaseclass(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.importBaseclassWithHttpInfo(className, authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }



    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public invalidateCache(authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.invalidateCacheWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param leftId 
     * @param rightId 
     * @param operationId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public linkBaseclassTouser(leftId: string, rightId: string, operationId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.linkBaseclassTouserWithHttpInfo(leftId, rightId, operationId, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Helper class for linking Role and User using a RoleUserContainer class, can be carried out by using the Generic createBaselink call
     * @summary Link Role and User
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public linkroleuser(authenticationkey?: string, body?: RoleUserContainer, extraHttpRequestParams?: any): Observable<RoleToUser> {
        return this.linkroleuserWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }



    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listAllLoadedPlugins(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<PluginInformationHolder>> {
        return this.listAllLoadedPluginsWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public listAllRoles(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Role>> {
        return this.listAllRolesWithHttpInfo(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listAllUserRoles(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Role>> {
        return this.listAllUserRolesWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public listAllUsers(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Array<UserClass>> {
        return this.listAllUsersWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }




    /**
     * lists license requests
     * @summary 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public listLicenseRequest(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Array<LicenseRequest>> {
        return this.listLicenseRequestWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * 
     * @param email 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public lookupUserByEmail(email: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<UserClass> {
        return this.lookupUserByEmailWithHttpInfo(email, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public lookupUserById(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<UserClass> {
        return this.lookupUserByIdWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param number 
     */
    public multipleCreate(authenticationkey?: string, number?: number, extraHttpRequestParams?: any): Observable<number> {
        return this.multipleCreateWithHttpInfo(authenticationkey, number, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * returns a list of instances of the type requested
     * @summary Find an instance by its name with wildcard
     * @param classname The canonical classname of the required entity list
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public nameLike(classname: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.nameLikeWithHttpInfo(classname, authenticationkey, body, pagesize, currentpage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     */
    public ping(extraHttpRequestParams?: any): Observable<boolean> {
        return this.pingWithHttpInfo(extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * registers components if not exists and returns allowed
     * @summary registerAndGetAllowedUIComponents
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public registerAndGetAllowedUIComponents(authenticationkey?: string, body?: UIComponentsRegistrationContainer, extraHttpRequestParams?: any): Observable<Array<UIComponent>> {
        return this.registerAndGetAllowedUIComponentsWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path 
     * @param calcMd5 
     */
    public registerFile(authenticationkey?: string, path?: string, calcMd5?: boolean, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.registerFileWithHttpInfo(authenticationkey, path, calcMd5, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path 
     * @param hint 
     * @param fileType 
     * @param dontProcess 
     * @param calcMd5 
     */
    public registerFileAndFinlize(authenticationkey?: string, path?: string, hint?: string, fileType?: string, dontProcess?: boolean, calcMd5?: boolean, extraHttpRequestParams?: any): Observable<Job> {
        return this.registerFileAndFinlizeWithHttpInfo(authenticationkey, path, hint, fileType, dontProcess, calcMd5, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }



    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public restart(authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.restartWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * soft delete baseclass
     * @summary softDelete
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public softDelete(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.softDeleteWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param jobID 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public stopJob(jobID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.stopJobWithHttpInfo(jobID, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public testUpdate(authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.testUpdateWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }



    /**
     * Update an instance of a Baseclass using a BasicContainer instance 
     * @summary Update basic data
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public updateBasicDetails(authenticationkey?: string, body?: BasicContainer, extraHttpRequestParams?: any): Observable<boolean> {
        return this.updateBasicDetailsWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param jobID 
     * @param phaseName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateJobPhase(jobID: string, phaseName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateJobPhaseWithHttpInfo(jobID, phaseName, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param jobID 
     * @param key 
     * @param value 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateJobProperty(jobID: string, key: string, value: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateJobPropertyWithHttpInfo(jobID, key, value, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }



    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public validate(authenticationkey?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.validateWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }




    /**
     * 
     * 
     * @param roleId 
     * @param userId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public addUserToRoleWithHttpInfo(roleId: string, userId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/addToRole/${roleId}/${userId}'
            .replace('${' + 'roleId' + '}', String(roleId))
            .replace('${' + 'userId' + '}', String(userId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'roleId' is not null or undefined
        if (roleId === null || roleId === undefined) {
            throw new Error('Required parameter roleId was null or undefined when calling addUserToRole.');
        }
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling addUserToRole.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param id 
     * @param crtId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public attachCertificateWithHttpInfo(id: string, crtId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/license/attachCertificate/${id}/${crtId}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'crtId' + '}', String(crtId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling attachCertificate.');
        }
        // verify required parameter 'crtId' is not null or undefined
        if (crtId === null || crtId === undefined) {
            throw new Error('Required parameter crtId was null or undefined when calling attachCertificate.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * attach file resource
     * attachs a file resource to the given media , using primary bundle
     * @param mediaId 
     * @param fileResourceId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param group 
     */
    public attachFileResourceWithHttpInfo(mediaId: string, fileResourceId: string, authenticationkey?: string, group?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/attachFileResource/${media_id}/${fileResource_id}'
            .replace('${' + 'media_id' + '}', String(mediaId))
            .replace('${' + 'fileResource_id' + '}', String(fileResourceId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mediaId' is not null or undefined
        if (mediaId === null || mediaId === undefined) {
            throw new Error('Required parameter mediaId was null or undefined when calling attachFileResource.');
        }
        // verify required parameter 'fileResourceId' is not null or undefined
        if (fileResourceId === null || fileResourceId === undefined) {
            throw new Error('Required parameter fileResourceId was null or undefined when calling attachFileResource.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (group !== undefined && group !== null) {
            headers.set('group', String(group));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }



    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public attachTenantWithHttpInfo(authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/attachTennat';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param id 
     * @param fileResourceId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public changeMediaPrimaryFileResourceBundleWithHttpInfo(id: string, fileResourceId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/${id}/${fileResourceId}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'fileResourceId' + '}', String(fileResourceId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling changeMediaPrimaryFileResourceBundle.');
        }
        // verify required parameter 'fileResourceId' is not null or undefined
        if (fileResourceId === null || fileResourceId === undefined) {
            throw new Error('Required parameter fileResourceId was null or undefined when calling changeMediaPrimaryFileResourceBundle.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     */
    public checkDBAvailableWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/ping/checkDBAvailable';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Connect to Category
     * Connect a Category to an instance of any entity in the system
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param catId The ID of an existing Category
     */
    public connectCategoryWithHttpInfo(baseId: string, authenticationkey?: string, catId?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling connectCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (catId !== undefined && catId !== null) {
            headers.set('catId', String(catId));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * connectDeviceToBaseclass
     * Connect a Device to an instance of any entity in the system
     * @param baseId 
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param someHeader 
     */
    public connectDeviceToBaseclassWithHttpInfo(baseId: string, mac: string, authenticationkey?: string, someHeader?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/connectDeviceToBaseclass/${mac}/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId))
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling connectDeviceToBaseclass.');
        }
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling connectDeviceToBaseclass.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (someHeader !== undefined && someHeader !== null) {
            headers.set('someHeader', String(someHeader));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * connect Property
     * Connect a property and a baseclass with a complex type, this is the actual action of assigning a Complex Value of a property to a specific Baseclass , any Baseclasss
     * @param propertyId the ID of the Property instance to use
     * @param baseclassId The ID of the Baseclass to which we want to assign this complex value
     * @param valueId The ID of the ? extends Baseclass which is the complex value
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public connectPropertyComplexWithHttpInfo(propertyId: string, baseclassId: string, valueId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/connectComplex/${propertyId}/${baseclass_id}/${value_id}'
            .replace('${' + 'propertyId' + '}', String(propertyId))
            .replace('${' + 'baseclass_id' + '}', String(baseclassId))
            .replace('${' + 'value_id' + '}', String(valueId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'propertyId' is not null or undefined
        if (propertyId === null || propertyId === undefined) {
            throw new Error('Required parameter propertyId was null or undefined when calling connectPropertyComplex.');
        }
        // verify required parameter 'baseclassId' is not null or undefined
        if (baseclassId === null || baseclassId === undefined) {
            throw new Error('Required parameter baseclassId was null or undefined when calling connectPropertyComplex.');
        }
        // verify required parameter 'valueId' is not null or undefined
        if (valueId === null || valueId === undefined) {
            throw new Error('Required parameter valueId was null or undefined when calling connectPropertyComplex.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * connect Property
     * Connect property and a baseclass with simple value, assign a value of a Property to an instance of Baseclass, any Baseclass instance
     * @param propertyId The ID of the property, this Property must be connected eith the Clazz of the Baseclass in the baseclass_id parameter
     * @param baseclassId The Baseclass instance to which this value (for that property) is set
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param simpleValue The value to set, must be a String
     */
    public connectPropertySimpleWithHttpInfo(propertyId: string, baseclassId: string, authenticationkey?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/connectSimple/${propertyId}/${baseclass_id}'
            .replace('${' + 'propertyId' + '}', String(propertyId))
            .replace('${' + 'baseclass_id' + '}', String(baseclassId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'propertyId' is not null or undefined
        if (propertyId === null || propertyId === undefined) {
            throw new Error('Required parameter propertyId was null or undefined when calling connectPropertySimple.');
        }
        // verify required parameter 'baseclassId' is not null or undefined
        if (baseclassId === null || baseclassId === undefined) {
            throw new Error('Required parameter baseclassId was null or undefined when calling connectPropertySimple.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public connectToTenantWithHttpInfo(authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/connectToTenant';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param type 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public countWithHttpInfo(type: string, authenticationkey?: string, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/count/${type}'
            .replace('${' + 'type' + '}', String(type));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling count.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public countAllofTypeWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/count';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public countConnectedWithHttpInfo(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/countConnected/${wantedClazzName}/${id}/${linkClazzName}'
            .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling countConnected.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling countConnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling countConnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public countDisconnectedWithHttpInfo(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder,
        pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/countDisconnected/${wantedClazzName}/${id}/${linkClazzName}'
            .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling countDisconnected.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling countDisconnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling countDisconnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }


    /**
     * Create a link
     * Creates a link between two instances in a generic way, provide values of the link
     * @param leftId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param rightId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value The ID of any instance inheriting from FC Baseclass, this effectively creates a triple link
     * @param simpleValue An explicit value of a string that can be part of the link
     * @param check If true, check if the link with these Left, Right and Complex Value values exists, if yes, then it will not be created
     */
    public createBaselinkWithHttpInfo(leftId: string, rightId: string, linkClazzName: string, authenticationkey?: string, value?: string, simpleValue?: string, check?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/${leftId}/${linkClazzName}/${rightId}'
            .replace('${' + 'leftId' + '}', String(leftId))
            .replace('${' + 'rightId' + '}', String(rightId))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'leftId' is not null or undefined
        if (leftId === null || leftId === undefined) {
            throw new Error('Required parameter leftId was null or undefined when calling createBaselink.');
        }
        // verify required parameter 'rightId' is not null or undefined
        if (rightId === null || rightId === undefined) {
            throw new Error('Required parameter rightId was null or undefined when calling createBaselink.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling createBaselink.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }

        if (check !== undefined && check !== null) {
            headers.set('check', String(check));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Create a Category
     * Return a single category
     * @param categoryName Inside a user interface categories are displayed by thier name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public createCategoryWithHttpInfo(categoryName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'categoryName' is not null or undefined
        if (categoryName === null || categoryName === undefined) {
            throw new Error('Required parameter categoryName was null or undefined when calling createCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (categoryName !== undefined && categoryName !== null) {
            headers.set('categoryName', String(categoryName));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * createDevice
     * creates a device
     * @param mac 
     * @param serialNumber 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param name 
     * @param lat 
     * @param lon 
     */
    public createDeviceWithHttpInfo(mac: string, serialNumber: string, authenticationkey?: string, name?: string, lat?: number,
        lon?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/createDevice/${mac}/${serialNumber}'
            .replace('${' + 'mac' + '}', String(mac))
            .replace('${' + 'serialNumber' + '}', String(serialNumber));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling createDevice.');
        }
        // verify required parameter 'serialNumber' is not null or undefined
        if (serialNumber === null || serialNumber === undefined) {
            throw new Error('Required parameter serialNumber was null or undefined when calling createDevice.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (name !== undefined && name !== null) {
            headers.set('name', String(name));
        }

        if (lat !== undefined && lat !== null) {
            headers.set('lat', String(lat));
        }

        if (lon !== undefined && lon !== null) {
            headers.set('lon', String(lon));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * createHeapDump
     * create heap dump
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path 
     */
    public createHeapDumpWithHttpInfo(authenticationkey?: string, pathparam?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/debug/createHeapDump';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (path !== undefined && path !== null) {
            headers.set('path', String(pathparam));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }



    /**
     * creates Property
     * creates a property given a type and a name, properties can be created and linked with Types. instances of these types can have associated values
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyName 
     * @param propertyType 
     */
    public createPropertyWithHttpInfo(authenticationkey?: string, propertyName?: string, propertyType?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (propertyName !== undefined && propertyName !== null) {
            headers.set('propertyName', String(propertyName));
        }

        if (propertyType !== undefined && propertyType !== null) {
            headers.set('propertyType', String(propertyType));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * creates Property Type
     * creates a property Type given  a name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyTypeName  the name of the property type to create
     */
    public createPropertyTypeWithHttpInfo(authenticationkey?: string, propertyTypeName?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/createType';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (propertyTypeName !== undefined && propertyTypeName !== null) {
            headers.set('propertyTypeName', String(propertyTypeName));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public createRoleWithHttpInfo(authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/roles';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }




    /**
     * 
     * 
     * @param tenantName 
     * @param apiKey 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public createTenantWithHttpInfo(tenantName: string, apiKey: string, authenticationkey?: string, body?: NewUser, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/tenant/${tenant_name}/${apiKey}'
            .replace('${' + 'tenant_name' + '}', String(tenantName))
            .replace('${' + 'apiKey' + '}', String(apiKey));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'tenantName' is not null or undefined
        if (tenantName === null || tenantName === undefined) {
            throw new Error('Required parameter tenantName was null or undefined when calling createTenant.');
        }
        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling createTenant.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param tenantName 
     * @param apiKey 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public createTenantNoUserWithHttpInfo(tenantName: string, apiKey: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/tenant/createTenantNoUser/${tenant_name}/${apiKey}'
            .replace('${' + 'tenant_name' + '}', String(tenantName))
            .replace('${' + 'apiKey' + '}', String(apiKey));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'tenantName' is not null or undefined
        if (tenantName === null || tenantName === undefined) {
            throw new Error('Required parameter tenantName was null or undefined when calling createTenantNoUser.');
        }
        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling createTenantNoUser.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * createUIInterface
     * creates UI interface
     * @param name 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public createUIInterfaceWithHttpInfo(name: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/uiPlugin/createUIInterface/${name}'
            .replace('${' + 'name' + '}', String(name));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createUIInterface.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param loginuponsuccess 
     * @param body 
     */
    public createUserWithHttpInfo(authenticationkey?: string, loginuponsuccess?: boolean, body?: NewUserUserClass, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/new';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (loginuponsuccess !== undefined && loginuponsuccess !== null) {
            headers.set('loginuponsuccess', String(loginuponsuccess));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }



    /**
     * deactivateAllLinks
     * deactivate all links between a device and baseclass
     * @param baseId 
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deactivateAllLinksWithHttpInfo(baseId: string, mac: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/deactivateAllLinks/${mac}/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId))
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling deactivateAllLinks.');
        }
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling deactivateAllLinks.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * deactivateLink
     * deactivate link 
     * @param linkId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deactivateLinkWithHttpInfo(linkId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/deactivateLink/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling deactivateLink.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * delete
     * deletes an entity by id
     * @param id The id of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteByIdWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteById.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions = new HttpRequest(
            'DELETE',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * delete
     * deletes an entity by id
     * @param id The id of the instance to be deleted
     * @param className The type of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteById_2WithHttpInfo(id: string, className: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/${class_name}/${id}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'class_name' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteById_2.');
        }
        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling deleteById_2.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions = new HttpRequest(
            'DELETE',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param md5 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteFileResourceWithHttpInfo(md5: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/resources/${md5}'
            .replace('${' + 'md5' + '}', String(md5));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'md5' is not null or undefined
        if (md5 === null || md5 === undefined) {
            throw new Error('Required parameter md5 was null or undefined when calling deleteFileResource.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions = new HttpRequest(
            'DELETE',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * deleteHeapDump
     * delete heap dump
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteHeapDumpWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/debug/deleteHeapDump/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteHeapDump.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'DELETE',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteMediaWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteMedia.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'DELETE',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Remove a link
     * Remove an existing link by the ID of its &#39;sides&#39;
     * @param leftId The ID of the left side of the link
     * @param rightId The ID of the right side of the link
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public detachEntitiesWithHttpInfo(leftId: string, rightId: string, linkClazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/${leftId}/${linkClazzName}/${rightId}'
            .replace('${' + 'leftId' + '}', String(leftId))
            .replace('${' + 'rightId' + '}', String(rightId))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'leftId' is not null or undefined
        if (leftId === null || leftId === undefined) {
            throw new Error('Required parameter leftId was null or undefined when calling detachEntities.');
        }
        // verify required parameter 'rightId' is not null or undefined
        if (rightId === null || rightId === undefined) {
            throw new Error('Required parameter rightId was null or undefined when calling detachEntities.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling detachEntities.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'DELETE',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * device get settings
     * create Settings
     * @param settingsId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deviceGetSettingsWithHttpInfo(settingsId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/deviceGetSettings/${settingsId}'
            .replace('${' + 'settingsId' + '}', String(settingsId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'settingsId' is not null or undefined
        if (settingsId === null || settingsId === undefined) {
            throw new Error('Required parameter settingsId was null or undefined when calling deviceGetSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Disable Category on Class
     * Disable a previously disabled Category, the CategoryID to be enabled is passed as the entity in the Post request(!)
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.User&#39; 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public disableCategoryWithHttpInfo(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/${class_name}/disable'
            .replace('${' + 'class_name' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling disableCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Disconnect from Category
     * Disconnect a Category from an instance of a connected(to this Category) entity in the system
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass and connected to the specified Category
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param catId The ID of an existing Category
     */
    public disconnectCategoryWithHttpInfo(baseId: string, authenticationkey?: string, catId?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling disconnectCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (catId !== undefined && catId !== null) {
            headers.set('catId', String(catId));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'DELETE',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param id id of the FileResource Object to Download
     */
    public downloadWithHttpInfo(authenticationkey: string, id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/download/${authenticationkey}/${id}'
            .replace('${' + 'authenticationkey' + '}', String(authenticationkey))
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'authenticationkey' is not null or undefined
        if (authenticationkey === null || authenticationkey === undefined) {
            throw new Error('Required parameter authenticationkey was null or undefined when calling download.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling download.');
        }

        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * duplicate an entity, shallow by id 
     * duplicate an entity by Id , returns null if not successfully duplicated
     * @param id The ID of the entity required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public duplicateWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/clone/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling duplicate.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }



    /**
     * Enable Category on Class
     * Before a Category can be connected to an INSTANCE of a class it must be enabled to the class, thus a list of categories can be easily filtered by the context of the class at hand, the CategoryID to be enabled is passed as the entity in the Post request(!)
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.User&#39; 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public enableCategoryWithHttpInfo(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/enable/${class_name}'
            .replace('${' + 'class_name' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling enableCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * export baseclass
     * exports to file 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public exportBaseclassWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/exportBaseclass/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling exportBaseclass.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * export settings
     * export Settings
     * @param settingsId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public exportSettingsWithHttpInfo(settingsId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/exportSettings/${settingsId}'
            .replace('${' + 'settingsId' + '}', String(settingsId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'settingsId' is not null or undefined
        if (settingsId === null || settingsId === undefined) {
            throw new Error('Required parameter settingsId was null or undefined when calling exportSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public fileResourcesOfTypeWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/fileResourcesOfType';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * finalize
     * finalize FileResource , sending it for processing
     * @param md5 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param hint 
     * @param fileType 
     * @param dontProcess 
     */
    public finalizeUploadWithHttpInfo(md5: string, authenticationkey?: string, hint?: string, fileType?: string, dontProcess?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/resources/finalize/${md5}'
            .replace('${' + 'md5' + '}', String(md5));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'md5' is not null or undefined
        if (md5 === null || md5 === undefined) {
            throw new Error('Required parameter md5 was null or undefined when calling finalizeUpload.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (hint !== undefined && hint !== null) {
            headers.set('hint', String(hint));
        }

        if (fileType !== undefined && fileType !== null) {
            headers.set('fileType', String(fileType));
        }

        if (dontProcess !== undefined && dontProcess !== null) {
            headers.set('dontProcess', String(dontProcess));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * find entity by id and class
     * Find an entity by Id and type, returns null if not found
     * @param id The ID of the entity required
     * @param classname The canonical classname of the required entity
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findByIdWithHttpInfo(id: string, classname: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/getbyid/${id}/${classname}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findById.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findById.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Find an instance by ID
     * Find an instance of a Baseclass extender by its id, returns an instance of a Baseclass
     * @param ID The id of instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findById_3WithHttpInfo(ID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/${id}'
            .replace('${' + 'ID' + '}', String(ID));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'ID' is not null or undefined
        if (ID === null || ID === undefined) {
            throw new Error('Required parameter ID was null or undefined when calling findById_3.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findById_4WithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/roles/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findById_4.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Find an instance by its name
     * returns a list of instances of the type requested
     * @param name The name of instance to be found
     * @param classname The cannonical classname of the instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findByNameWithHttpInfo(name: string, classname: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/${name}/${classname}'
            .replace('${' + 'Name' + '}', String(name))
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling findByName.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findByName.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     */
    public findBySidesIdWithHttpInfo(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/${left}/${right}/${classname}'
            .replace('${' + 'left' + '}', String(left))
            .replace('${' + 'right' + '}', String(right))
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findBySidesId.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findBySidesId.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findBySidesId.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksWithHttpInfo(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/findLinks/${left}/${right}/${classname}'
            .replace('${' + 'left' + '}', String(left))
            .replace('${' + 'right' + '}', String(right))
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findLinks.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findLinks.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findLinks.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksContainersWithHttpInfo(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/findLinksContainers/${left}/${right}/${classname}'
            .replace('${' + 'left' + '}', String(left))
            .replace('${' + 'right' + '}', String(right))
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findLinksContainers.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findLinksContainers.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findLinksContainers.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksValuesWithHttpInfo(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/findLinksValues/${left}/${right}/${classname}'
            .replace('${' + 'left' + '}', String(left))
            .replace('${' + 'right' + '}', String(right))
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findLinksValues.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findLinksValues.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findLinksValues.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param clientType 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view 
     */
    public generateClientWithHttpInfo(clientType: string, authenticationkey?: string, view?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/swagger/extended/generateClient/${client_type}'
            .replace('${' + 'client_type' + '}', String(clientType));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'clientType' is not null or undefined
        if (clientType === null || clientType === undefined) {
            throw new Error('Required parameter clientType was null or undefined when calling generateClient.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (view !== undefined && view !== null) {
            headers.set('view', String(view));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param targetDevice 
     */
    public getWithHttpInfo(id: string, authenticationkey?: string, targetDevice?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling get.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (targetDevice !== undefined && targetDevice !== null) {
            headers.set('targetDevice', String(targetDevice));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Get a list of Categories  by name
     * Get a list of all Categories whose name starts with the supplied string
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getAllCategoriesWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/getAll';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * List Categories  by Instance
     * Get a list of all Categories that are connected to an instance
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllCategoriesConnectedWithHttpInfo(baseId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/connected/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling getAllCategoriesConnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllFileTypesWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/types';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Get all Operations
     * Get a list of all Operations defined for the this Class, Some Operations have meaning with some Classes only
     * @param clazzName The canonical classname of the link required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllOperationsWithHttpInfo(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/clazz/operations/${clazzName}'
            .replace('${' + 'clazzName' + '}', String(clazzName));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'clazzName' is not null or undefined
        if (clazzName === null || clazzName === undefined) {
            throw new Error('Required parameter clazzName was null or undefined when calling getAllOperations.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * returns a list of views
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllViewsWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/view';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Get a list of all associations 
     * Returns a list of ClazzLinkContainer instances of the given link(!) canonical name
     * @param clazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAssociationsWithHttpInfo(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/clazz/associations/${clazzName}'
            .replace('${' + 'clazzName' + '}', String(clazzName));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'clazzName' is not null or undefined
        if (clazzName === null || clazzName === undefined) {
            throw new Error('Required parameter clazzName was null or undefined when calling getAssociations.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * List Categories  by Class
     * Get a list of all Categories that can be used (previously enabled) by a Class
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.media.Media&#39; will retrieve only Categories that can be used with a Media Object(Instance)
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getCategoryWithHttpInfo(className: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/${class_name}'
            .replace('${' + 'class_name' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling getCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Get a list of Categories  by name
     * Get a list of all Categories whose name starts with the supplied string
     * @param name A string that must match the left characters of a retrieved Category name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getCategoryByNameWithHttpInfo(name: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/byname/${name}'
            .replace('${' + 'name' + '}', String(name));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getCategoryByName.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Get a Clazz instance from a canonical name
     * Return a concrete instance of type Clazz, every type in the system including those created by Plug-ins have a concrete instance of Clazz type describing it.
     * @param clazzName The canonical classname for which the instance is required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getClazzWithHttpInfo(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/clazz/${clazzName}'
            .replace('${' + 'clazzName' + '}', String(clazzName));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'clazzName' is not null or undefined
        if (clazzName === null || clazzName === undefined) {
            throw new Error('Required parameter clazzName was null or undefined when calling getClazz.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getClientsWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/swagger/extended/clients';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getConnectedWithHttpInfo(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/connected/${wantedClazzName}/${id}/${linkClazzName}'
            .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling getConnected.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getConnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling getConnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * getDeviceUsedProperties
     * update device used properties
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public getDeviceUsedPropertiesWithHttpInfo(mac: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/getDeviceUsedProperties/${mac}'
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling getDeviceUsedProperties.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param id 
     * @param wantedClazzName 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getDisconnectedWithHttpInfo(id: string, wantedClazzName: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/disconnected/${wantedClazzName}/${id}/${linkClazzName}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDisconnected.');
        }
        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling getDisconnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling getDisconnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view 
     */
    public getDocsWithHttpInfo(authenticationkey: string, view?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/swagger/extended/docs/${authenticationkey}'
            .replace('${' + 'authenticationkey' + '}', String(authenticationkey));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'authenticationkey' is not null or undefined
        if (authenticationkey === null || authenticationkey === undefined) {
            throw new Error('Required parameter authenticationkey was null or undefined when calling getDocs.');
        }
        if (view !== undefined && view !== null) {
            headers.set('view', String(view));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * get Connected Properties
     * get all properties connected to baseclass
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyClazz 
     * @param plainView 
     */
    public getDynamicPropertiesWithHttpInfo(id: string, authenticationkey?: string, propertyClazz?: string, plainView?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDynamicProperties.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (propertyClazz !== undefined && propertyClazz !== null) {
            headers.set('propertyClazz', String(propertyClazz));
        }

        if (plainView !== undefined && plainView !== null) {
            headers.set('plainView', String(plainView));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * get Connected Properties With Categories
     * get all properties connected to baseclass
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyClazz 
     * @param plainView 
     */
    public getDynamicPropertiesWithCategoriesWithHttpInfo(id: string, authenticationkey?: string, propertyClazz?: string, plainView?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/getDynamicPropertiesWithCategories/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDynamicPropertiesWithCategories.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (propertyClazz !== undefined && propertyClazz !== null) {
            headers.set('propertyClazz', String(propertyClazz));
        }

        if (plainView !== undefined && plainView !== null) {
            headers.set('plainView', String(plainView));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public getFeaturesWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/license/getFeatures';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Get Field Containers per class
     * get a list of all FieldContainers per class, use it for the creation of a new instance and for updating one
     * @param clazzName The canonical name of the Class for which the list is to be obtained
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getFieldsWithHttpInfo(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/clazz/fields/${clazzName}'
            .replace('${' + 'clazzName' + '}', String(clazzName));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'clazzName' is not null or undefined
        if (clazzName === null || clazzName === undefined) {
            throw new Error('Required parameter clazzName was null or undefined when calling getFields.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param className 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getFields_5WithHttpInfo(className: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/${class_name}/fields'
            .replace('${' + 'class_name' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling getFields_5.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param md5 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getFileResourceWithHttpInfo(md5: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/resources/${md5}'
            .replace('${' + 'md5' + '}', String(md5));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'md5' is not null or undefined
        if (md5 === null || md5 === undefined) {
            throw new Error('Required parameter md5 was null or undefined when calling getFileResource.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param jobID 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getJobWithHttpInfo(jobID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/jobProcess/${jobID}'
            .replace('${' + 'jobID' + '}', String(jobID));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'jobID' is not null or undefined
        if (jobID === null || jobID === undefined) {
            throw new Error('Required parameter jobID was null or undefined when calling getJob.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }



    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view 
     */
    public getSwaggerJSONWithHttpInfo(authenticationkey: string, view?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/swagger/extended/swagger.json/${authenticationkey}'
            .replace('${' + 'authenticationkey' + '}', String(authenticationkey));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'authenticationkey' is not null or undefined
        if (authenticationkey === null || authenticationkey === undefined) {
            throw new Error('Required parameter authenticationkey was null or undefined when calling getSwaggerJSON.');
        }
        if (view !== undefined && view !== null) {
            headers.set('view', String(view));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param apiKey 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getTenantWithHttpInfo(apiKey: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/tenant/${apiKey}'
            .replace('${' + 'apiKey' + '}', String(apiKey));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling getTenant.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getTenantsWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/tenant';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param viewId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getViewClazzesWithHttpInfo(viewId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/view/clazzes/${viewId}'
            .replace('${' + 'viewId' + '}', String(viewId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'viewId' is not null or undefined
        if (viewId === null || viewId === undefined) {
            throw new Error('Required parameter viewId was null or undefined when calling getViewClazzes.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * import baseclass
     * import baseclass
     * @param className 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public importBaseclassWithHttpInfo(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/importBaseclass/${className}'
            .replace('${' + 'className' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling importBaseclass.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }



    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public invalidateCacheWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/swagger/extended/invalidateCache';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param leftId 
     * @param rightId 
     * @param operationId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public linkBaseclassTouserWithHttpInfo(leftId: string, rightId: string, operationId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/linkUserToBaseclass/${left_id}/${right_id}/${operation_id}'
            .replace('${' + 'left_id' + '}', String(leftId))
            .replace('${' + 'right_id' + '}', String(rightId))
            .replace('${' + 'operation_id' + '}', String(operationId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'leftId' is not null or undefined
        if (leftId === null || leftId === undefined) {
            throw new Error('Required parameter leftId was null or undefined when calling linkBaseclassTouser.');
        }
        // verify required parameter 'rightId' is not null or undefined
        if (rightId === null || rightId === undefined) {
            throw new Error('Required parameter rightId was null or undefined when calling linkBaseclassTouser.');
        }
        // verify required parameter 'operationId' is not null or undefined
        if (operationId === null || operationId === undefined) {
            throw new Error('Required parameter operationId was null or undefined when calling linkBaseclassTouser.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Link Role and User
     * Helper class for linking Role and User using a RoleUserContainer class, can be carried out by using the Generic createBaselink call
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public linkroleuserWithHttpInfo(authenticationkey?: string, body?: RoleUserContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/linkroleuser';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param sortby 
     */
    public listAllWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, sortby?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }

        if (sortby !== undefined && sortby !== null) {
            headers.set('sortby', String(sortby));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * fileResourcesInMediaByGroup
     * lists all media that suites Filtering information holder
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param group 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public listAllFileResourcesOfGroupInMediaWithHttpInfo(id: string, authenticationkey?: string, group?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/list/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listAllFileResourcesOfGroupInMedia.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (group !== undefined && group !== null) {
            headers.set('group', String(group));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * get file resources
     * returns all the file resources of the given types that are connected to the given Media
     * @param mediaId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public listAllFileResourcesOfTypeWithHttpInfo(mediaId: string, authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/fileResources/${media_id}'
            .replace('${' + 'media_id' + '}', String(mediaId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mediaId' is not null or undefined
        if (mediaId === null || mediaId === undefined) {
            throw new Error('Required parameter mediaId was null or undefined when calling listAllFileResourcesOfType.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listAllLoadedPluginsWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public listAllRolesWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/roles/list';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * lists all Settings
     * lists all settings
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public listAllSettingsWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/listAllSettings';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * lists all Settings Metadata
     * lists all settings metadata
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public listAllSettingsMetadataWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listAllUserRolesWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/roles/userRoles/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listAllUserRoles.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public listAllUsersWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * lists all media that suites Filtering information holder
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public listAllofTypeWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * listDeviceSettingss
     * list device Settings
     * @param deviceId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listDeviceSettingsWithHttpInfo(deviceId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/listDeviceSettings/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling listDeviceSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * listDeviceSettingsContainers
     * list device Settings containers
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listDeviceSettingsContainersWithHttpInfo(mac: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/listDeviceSettingsContainers/${mac}'
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling listDeviceSettingsContainers.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listDevicesWithHttpInfo(authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/listDevices';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * listHeapDumps
     * list heap dumps
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param start 
     */
    public listHeapDumpsWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, start?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/debug/listHeapDumps';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }

        if (start !== undefined && start !== null) {
            headers.set('start', String(start));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * lists license requests
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public listLicenseRequestWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/license/listAll';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * listProperties
     * get all Properties, paged, filtered and sorted by a FilteringInformationHolder
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listPropertiesWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/listProperties';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * listPropertyTypes
     * get all property types, filtered and sorted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listPropertyTypesWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/listPropertyTypes';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * lists Settings
     * lists settings
     * @param settingsMetadataId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public listSettingsWithHttpInfo(settingsMetadataId: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/listSettings/${settingsMetadataId}'
            .replace('${' + 'settingsMetadataId' + '}', String(settingsMetadataId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'settingsMetadataId' is not null or undefined
        if (settingsMetadataId === null || settingsMetadataId === undefined) {
            throw new Error('Required parameter settingsMetadataId was null or undefined when calling listSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * listUIInterfaces
     * lists ui interfaces
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public listUIInterfacesWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/uiPlugin/listUIInterfaces';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * listUIPluginsByInterface
     * lists plugin by interface
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param interfaceId 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public listUIPluginsByInterfaceWithHttpInfo(authenticationkey?: string, interfaceId?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/uiPlugin/listUIPluginsByInterface/${interfaceId}';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (interfaceId !== undefined && interfaceId !== null) {
            headers.set('interfaceId', String(interfaceId));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param email 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public lookupUserByEmailWithHttpInfo(email: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/byEmail/${email}'
            .replace('${' + 'email' + '}', String(email));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling lookupUserByEmail.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public lookupUserByIdWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/byId/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling lookupUserById.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param number 
     */
    public multipleCreateWithHttpInfo(authenticationkey?: string, number?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/batchCreate';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (number !== undefined && number !== null) {
            headers.set('number', String(number));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * Find an instance by its name with wildcard
     * returns a list of instances of the type requested
     * @param classname The canonical classname of the required entity list
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public nameLikeWithHttpInfo(classname: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/like/name/${classname}'
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling nameLike.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     */
    public pingWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/ping';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * registerAndGetAllowedUIComponents
     * registers components if not exists and returns allowed
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public registerAndGetAllowedUIComponentsWithHttpInfo(authenticationkey?: string, body?: UIComponentsRegistrationContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/uiPlugin/registerAndGetAllowedUIComponents';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path 
     * @param calcMd5 
     */
    public registerFileWithHttpInfo(authenticationkey?: string, pathparam?: string, calcMd5?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/resources/register';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (path !== undefined && path !== null) {
            headers.set('path', String(pathparam));
        }

        if (calcMd5 !== undefined && calcMd5 !== null) {
            headers.set('calcMd5', String(calcMd5));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path 
     * @param hint 
     * @param fileType 
     * @param dontProcess 
     * @param calcMd5 
     */
    public registerFileAndFinlizeWithHttpInfo(authenticationkey?: string, pathparam?: string, hint?: string, fileType?: string, dontProcess?: boolean, calcMd5?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/resources/registerAndFinalize';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(pathparam));
        }

        if (path !== undefined && path !== null) {
            headers.set('path', String(path));
        }

        if (hint !== undefined && hint !== null) {
            headers.set('hint', String(hint));
        }

        if (fileType !== undefined && fileType !== null) {
            headers.set('fileType', String(fileType));
        }

        if (dontProcess !== undefined && dontProcess !== null) {
            headers.set('dontProcess', String(dontProcess));
        }

        if (calcMd5 !== undefined && calcMd5 !== null) {
            headers.set('calcMd5', String(calcMd5));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'POST',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }


    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public restartWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * setsActiveSettings
     * sets active settings for settingsMetadata
     * @param settingsMetaId 
     * @param settingId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public setActiveSettingsWithHttpInfo(settingsMetaId: string, settingId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/setActiveSettings/${settingsMetaId}/${settingId}'
            .replace('${' + 'settingsMetaId' + '}', String(settingsMetaId))
            .replace('${' + 'settingId' + '}', String(settingId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'settingsMetaId' is not null or undefined
        if (settingsMetaId === null || settingsMetaId === undefined) {
            throw new Error('Required parameter settingsMetaId was null or undefined when calling setActiveSettings.');
        }
        // verify required parameter 'settingId' is not null or undefined
        if (settingId === null || settingId === undefined) {
            throw new Error('Required parameter settingId was null or undefined when calling setActiveSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * setActiveSettingsAsDefault
     * sets active settings for settingsMetadata as null(using default values)
     * @param settingsMetaId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public setActiveSettingsAsDefaultWithHttpInfo(settingsMetaId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/setActiveSettingsAsDefault/${settingsMetaId}'
            .replace('${' + 'settingsMetaId' + '}', String(settingsMetaId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'settingsMetaId' is not null or undefined
        if (settingsMetaId === null || settingsMetaId === undefined) {
            throw new Error('Required parameter settingsMetaId was null or undefined when calling setActiveSettingsAsDefault.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }




    /**
     * softDelete
     * soft delete baseclass
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public softDeleteWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/softDelete/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling softDelete.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'DELETE',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param jobID 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public stopJobWithHttpInfo(jobID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/jobProcess/${jobID}'
            .replace('${' + 'jobID' + '}', String(jobID));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'jobID' is not null or undefined
        if (jobID === null || jobID === undefined) {
            throw new Error('Required parameter jobID was null or undefined when calling stopJob.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'DELETE',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public testUpdateWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/testUpdate';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }



    /**
     * Update basic data
     * Update an instance of a Baseclass using a BasicContainer instance 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public updateBasicDetailsWithHttpInfo(authenticationkey?: string, body?: BasicContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param jobID 
     * @param phaseName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateJobPhaseWithHttpInfo(jobID: string, phaseName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/jobProcess/updateJobPhase/${jobID}/${phaseName}'
            .replace('${' + 'jobID' + '}', String(jobID))
            .replace('${' + 'phaseName' + '}', String(phaseName));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'jobID' is not null or undefined
        if (jobID === null || jobID === undefined) {
            throw new Error('Required parameter jobID was null or undefined when calling updateJobPhase.');
        }
        // verify required parameter 'phaseName' is not null or undefined
        if (phaseName === null || phaseName === undefined) {
            throw new Error('Required parameter phaseName was null or undefined when calling updateJobPhase.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param jobID 
     * @param key 
     * @param value 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateJobPropertyWithHttpInfo(jobID: string, key: string, value: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/jobProcess/updateJobProperty/${jobID}/${key}/${value}'
            .replace('${' + 'jobID' + '}', String(jobID))
            .replace('${' + 'key' + '}', String(key))
            .replace('${' + 'value' + '}', String(value));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'jobID' is not null or undefined
        if (jobID === null || jobID === undefined) {
            throw new Error('Required parameter jobID was null or undefined when calling updateJobProperty.');
        }
        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling updateJobProperty.');
        }
        // verify required parameter 'value' is not null or undefined
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling updateJobProperty.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * update metadata property
     * update metadata property
     * @param linkId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param simpleValue 
     */
    public updateMetadataSimpleWithHttpInfo(linkId: string, authenticationkey?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/updateMetadataSimple/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling updateMetadataSimple.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * updateSimple
     * update Simple value of a Dynamic Property of a Baseclass instance
     * @param linkId The link id (of PropertyToBaseclass type)
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param simpleValue The value to update
     */
    public updateSimpleWithHttpInfo(linkId: string, authenticationkey?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/updateSimple/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling updateSimple.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    /**
     * 
     * 
     * @param id 
     * @param updateTo 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateVersionWithHttpInfo(id: string, updateTo: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/updateVersion/${id}/${updateTo}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'updateTo' + '}', String(updateTo));

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateVersion.');
        }
        // verify required parameter 'updateTo' is not null or undefined
        if (updateTo === null || updateTo === undefined) {
            throw new Error('Required parameter updateTo was null or undefined when calling updateVersion.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'PUT',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }




    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public validateWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/resources/validate';

        let queryParameters = new URLSearchParams();
        let headers = this.defaultHeaders; // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions = new HttpRequest(
            'GET',
            path,
            {
                headers: headers,
                search: queryParameters,
                withCredentials: this.configuration.withCredentials
            });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.httpClient.request(requestOptions).map(o => FlexiCoreDecycle.retrocycle(o));
    }

    public getFileResourceByMD5(md5: string, authenticationKey?: string, observe?: 'body', reportProgress?: boolean): Observable<FileResource>;
    public getFileResourceByMD5(md5: string, authenticationKey?: string, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<FileResource>>;
    public getFileResourceByMD5(md5: string, authenticationKey?: string, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<FileResource>>;
    public getFileResourceByMD5(md5: string, authenticationKey?: string, observe: any = 'body', reportProgress: boolean = false): Observable<any> {

        let headers = this.defaultHeaders;
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers = headers.set('authenticationKey', String(authenticationKey));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.get<FileResource>(`${this.basePath}/resources/${md5}`,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        ).map(o => FlexiCoreDecycle.retrocycle(o));
    }

}
