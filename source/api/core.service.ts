/**
 * REST API for Flexicore filtered by your access rights
 * Flexicore REST API
 *
 * OpenAPI spec version: V1.1.0
 * Contact: avishaybennatan@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'; import { FlexiCoreDecycle } from './flexiCoreDecycle';
import { Http, Headers, URLSearchParams } from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response } from '@angular/http';

import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

import { Baseclass } from '../model/baseclass';
import { BaseclassCreationContainer } from '../model/baseclassCreationContainer';
import { BaseclassUpdateContainer } from '../model/baseclassUpdateContainer';
import { Baselink } from '../model/baselink';
import { BasicContainer } from '../model/basicContainer';
import { Category } from '../model/category';
import { Clazz } from '../model/clazz';
import { ClazzLinkContainer } from '../model/clazzLinkContainer';
import { Device } from '../model/device';
import { DevicePropertyContainerObject } from '../model/devicePropertyContainerObject';
import { DeviceSettingsContainer } from '../model/deviceSettingsContainer';
import { DeviceToBaseclass } from '../model/deviceToBaseclass';
import { DeviceUsedPropertiesContainer } from '../model/deviceUsedPropertiesContainer';
import { FieldContainer } from '../model/fieldContainer';
import { FileResource } from '../model/fileResource';
import { FileResourceBundleHolder } from '../model/fileResourceBundleHolder';
import { FileType } from '../model/fileType';
import { FilteringInformationHolder } from '../model/filteringInformationHolder';
import { Job } from '../model/job';
import { LicenseRequest } from '../model/licenseRequest';
import { LicensingFeature } from '../model/licensingFeature';
import { LicensingProduct } from '../model/licensingProduct';
import { LinkContainer } from '../model/linkContainer';
import { Media } from '../model/media';
import { MultipartFormDataInput } from '../model/multipartFormDataInput';
import { NewUser } from '../model/newUser';
import { NewUserUserClass } from '../model/newUserUserClass';
import { Operation } from '../model/operation';
import { PluginInformationHolder } from '../model/pluginInformationHolder';
import { Property } from '../model/property';
import { PropertyContainerSerializable } from '../model/propertyContainerSerializable';
import { PropertySetContainerBaseclass } from '../model/propertySetContainerBaseclass';
import { PropertyToBaseclass } from '../model/propertyToBaseclass';
import { PropertyToClazz } from '../model/propertyToClazz';
import { PropertyToSettingsMetadata } from '../model/propertyToSettingsMetadata';
import { PropertyType } from '../model/propertyType';
import { Role } from '../model/role';
import { RoleToUser } from '../model/roleToUser';
import { RoleUserContainer } from '../model/roleUserContainer';
import { RunningUser } from '../model/runningUser';
import { Settings } from '../model/settings';
import { SettingsContainer } from '../model/settingsContainer';
import { SettingsMetadata } from '../model/settingsMetadata';
import { SettingsMetadataCreationContainer } from '../model/settingsMetadataCreationContainer';
import { Tenant } from '../model/tenant';
import { UIComponent } from '../model/uIComponent';
import { UIComponentsRegistrationContainer } from '../model/uIComponentsRegistrationContainer';
import { UpdateBundle } from '../model/updateBundle';
import { UserClass } from '../model/userClass';
import { View } from '../model/view';

import { BASE_PATH } from '../variables';
import { Configuration } from '../configuration';


@Injectable()
export class CoreService {

    protected basePath = 'https://192.168.0.41:8080/FlexiCore/rest';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * 
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    private extendObj<T1, T2>(objA: T1, objB: T2) {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                (objA as any)[key] = (objB as any)[key];
            }
        }
        return <T1 & T2>objA;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    /**
     * activate a link between a device and baseclass
     * @summary activateLink
     * @param baseId 
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public activateLink(baseId: string, mac: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.activateLinkWithHttpInfo(baseId, mac, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param roleId 
     * @param userId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public addUserToRole(roleId: string, userId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.addUserToRoleWithHttpInfo(roleId, userId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param crtId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public attachCertificate(id: string, crtId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.attachCertificateWithHttpInfo(id, crtId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * attachs a file resource to the given media , using primary bundle
     * @summary attach file resource
     * @param mediaId 
     * @param fileResourceId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param group 
     */
    public attachFileResource(mediaId: string, fileResourceId: string, authenticationkey?: string, group?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.attachFileResourceWithHttpInfo(mediaId, fileResourceId, authenticationkey, group, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * attach Property to metadata
     * @summary attach Property to metadata
     * @param settingsMetaId 
     * @param propertyId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     */
    public attachPropertyToMetadata(settingsMetaId: string, propertyId: string, authenticationkey?: string, value?: string, extraHttpRequestParams?: any): Observable<PropertyToSettingsMetadata> {
        return this.attachPropertyToMetadataWithHttpInfo(settingsMetaId, propertyId, authenticationkey, value, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public attachTenant(authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.attachTenantWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param fileResourceId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public changeMediaPrimaryFileResourceBundle(id: string, fileResourceId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.changeMediaPrimaryFileResourceBundleWithHttpInfo(id, fileResourceId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     */
    public checkDBAvailable(extraHttpRequestParams?: any): Observable<boolean> {
        return this.checkDBAvailableWithHttpInfo(extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Connect a Category to an instance of any entity in the system
     * @summary Connect to Category
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param catId The ID of an existing Category
     */
    public connectCategory(baseId: string, authenticationkey?: string, catId?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.connectCategoryWithHttpInfo(baseId, authenticationkey, catId, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Connect a Device to an instance of any entity in the system
     * @summary connectDeviceToBaseclass
     * @param baseId 
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param someHeader 
     */
    public connectDeviceToBaseclass(baseId: string, mac: string, authenticationkey?: string, someHeader?: string, extraHttpRequestParams?: any): Observable<DeviceToBaseclass> {
        return this.connectDeviceToBaseclassWithHttpInfo(baseId, mac, authenticationkey, someHeader, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Connect a property and a baseclass with a complex type, this is the actual action of assigning a Complex Value of a property to a specific Baseclass , any Baseclasss
     * @summary connect Property
     * @param propertyId the ID of the Property instance to use
     * @param baseclassId The ID of the Baseclass to which we want to assign this complex value
     * @param valueId The ID of the ? extends Baseclass which is the complex value
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public connectPropertyComplex(propertyId: string, baseclassId: string, valueId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<PropertyToBaseclass> {
        return this.connectPropertyComplexWithHttpInfo(propertyId, baseclassId, valueId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Connect property and a baseclass with simple value, assign a value of a Property to an instance of Baseclass, any Baseclass instance
     * @summary connect Property
     * @param propertyId The ID of the property, this Property must be connected eith the Clazz of the Baseclass in the baseclass_id parameter
     * @param baseclassId The Baseclass instance to which this value (for that property) is set
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param simpleValue The value to set, must be a String
     */
    public connectPropertySimple(propertyId: string, baseclassId: string, authenticationkey?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<PropertyToBaseclass> {
        return this.connectPropertySimpleWithHttpInfo(propertyId, baseclassId, authenticationkey, simpleValue, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public connectToTenant(authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.connectToTenantWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param type 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public count(type: string, authenticationkey?: string, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<number> {
        return this.countWithHttpInfo(type, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public countAllofType(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<number> {
        return this.countAllofTypeWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public countConnected(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<number> {
        return this.countConnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public countDisconnected(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<number> {
        return this.countDisconnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Creates a new instance of the requested Class, pass a properly initialized instance of BaseclassCreationContainer
     * @summary Create an instance of a Baseclass extender
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public create(authenticationkey?: string, body?: BaseclassCreationContainer, extraHttpRequestParams?: any): Observable<string> {
        return this.createWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Creates a link between two instances in a generic way, provide values of the link
     * @summary Create a link
     * @param leftId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param rightId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value The ID of any instance inheriting from FC Baseclass, this effectively creates a triple link
     * @param simpleValue An explicit value of a string that can be part of the link
     * @param check If true, check if the link with these Left, Right and Complex Value values exists, if yes, then it will not be created
     */
    public createBaselink(leftId: string, rightId: string, linkClazzName: string, authenticationkey?: string, value?: string, simpleValue?: string, check?: boolean, extraHttpRequestParams?: any): Observable<Baselink> {
        return this.createBaselinkWithHttpInfo(leftId, rightId, linkClazzName, authenticationkey, value, simpleValue, check, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Return a single category
     * @summary Create a Category
     * @param categoryName Inside a user interface categories are displayed by thier name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public createCategory(categoryName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Category> {
        return this.createCategoryWithHttpInfo(categoryName, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * creates a device
     * @summary createDevice
     * @param mac 
     * @param serialNumber 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param name 
     * @param lat 
     * @param lon 
     */
    public createDevice(mac: string, serialNumber: string, authenticationkey?: string, name?: string, lat?: number, lon?: number, extraHttpRequestParams?: any): Observable<Device> {
        return this.createDeviceWithHttpInfo(mac, serialNumber, authenticationkey, name, lat, lon, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * create heap dump
     * @summary createHeapDump
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path 
     */
    public createHeapDump(authenticationkey?: string, path?: string, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.createHeapDumpWithHttpInfo(authenticationkey, path, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }



    /**
     * creates a property given a type and a name, properties can be created and linked with Types. instances of these types can have associated values
     * @summary creates Property
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyName 
     * @param propertyType 
     */
    public createProperty(authenticationkey?: string, propertyName?: string, propertyType?: string, extraHttpRequestParams?: any): Observable<Property> {
        return this.createPropertyWithHttpInfo(authenticationkey, propertyName, propertyType, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * creates a property Type given  a name
     * @summary creates Property Type
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyTypeName  the name of the property type to create
     */
    public createPropertyType(authenticationkey?: string, propertyTypeName?: string, extraHttpRequestParams?: any): Observable<PropertyType> {
        return this.createPropertyTypeWithHttpInfo(authenticationkey, propertyTypeName, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public createRole(authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Role> {
        return this.createRoleWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * create Settings
     * @summary create settings
     * @param settingsMetadataId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public createSettings(settingsMetadataId: string, authenticationkey?: string, body?: SettingsMetadataCreationContainer, extraHttpRequestParams?: any): Observable<Settings> {
        return this.createSettingsWithHttpInfo(settingsMetadataId, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * creates a settings metadata
     * @summary creates Settings Metadata
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body Settings metadata container
     */
    public createSettingsMetadata(authenticationkey?: string, body?: SettingsMetadataCreationContainer, extraHttpRequestParams?: any): Observable<SettingsMetadata> {
        return this.createSettingsMetadataWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param tenantName 
     * @param apiKey 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public createTenant(tenantName: string, apiKey: string, authenticationkey?: string, body?: NewUser, extraHttpRequestParams?: any): Observable<Tenant> {
        return this.createTenantWithHttpInfo(tenantName, apiKey, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param tenantName 
     * @param apiKey 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public createTenantNoUser(tenantName: string, apiKey: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Tenant> {
        return this.createTenantNoUserWithHttpInfo(tenantName, apiKey, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }


    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param loginuponsuccess 
     * @param body 
     */
    public createUser(authenticationkey?: string, loginuponsuccess?: boolean, body?: NewUserUserClass, extraHttpRequestParams?: any): Observable<RunningUser> {
        return this.createUserWithHttpInfo(authenticationkey, loginuponsuccess, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public create_1(authenticationkey?: string, body?: Media, extraHttpRequestParams?: any): Observable<{}> {
        return this.create_1WithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * deactivate all links between a device and baseclass
     * @summary deactivateAllLinks
     * @param baseId 
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deactivateAllLinks(baseId: string, mac: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<number> {
        return this.deactivateAllLinksWithHttpInfo(baseId, mac, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * deactivate link 
     * @summary deactivateLink
     * @param linkId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deactivateLink(linkId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.deactivateLinkWithHttpInfo(linkId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * deletes an entity by id
     * @summary delete
     * @param id The id of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteById(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteByIdWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * deletes an entity by id
     * @summary delete
     * @param id The id of the instance to be deleted
     * @param className The type of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteById_2(id: string, className: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteById_2WithHttpInfo(id, className, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param md5 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteFileResource(md5: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteFileResourceWithHttpInfo(md5, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * delete heap dump
     * @summary deleteHeapDump
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteHeapDump(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.deleteHeapDumpWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteMedia(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteMediaWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Remove an existing link by the ID of its 'sides'
     * @summary Remove a link
     * @param leftId The ID of the left side of the link
     * @param rightId The ID of the right side of the link
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public detachEntities(leftId: string, rightId: string, linkClazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.detachEntitiesWithHttpInfo(leftId, rightId, linkClazzName, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * create Settings
     * @summary device get settings
     * @param settingsId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deviceGetSettings(settingsId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<SettingsContainer> {
        return this.deviceGetSettingsWithHttpInfo(settingsId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Disable a previously disabled Category, the CategoryID to be enabled is passed as the entity in the Post request(!)
     * @summary Disable Category on Class
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.User&#39; 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public disableCategory(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.disableCategoryWithHttpInfo(className, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Disconnect a Category from an instance of a connected(to this Category) entity in the system
     * @summary Disconnect from Category
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass and connected to the specified Category
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param catId The ID of an existing Category
     */
    public disconnectCategory(baseId: string, authenticationkey?: string, catId?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.disconnectCategoryWithHttpInfo(baseId, authenticationkey, catId, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param id id of the FileResource Object to Download
     */
    public download(authenticationkey: string, id: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.downloadWithHttpInfo(authenticationkey, id, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * duplicate an entity by Id , returns null if not successfully duplicated
     * @summary duplicate an entity, shallow by id 
     * @param id The ID of the entity required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public duplicate(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Baseclass> {
        return this.duplicateWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * duplicate Settings
     * @summary duplicate settings
     * @param originalSettingsId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public duplicateSettings(originalSettingsId: string, authenticationkey?: string, body?: SettingsMetadataCreationContainer, extraHttpRequestParams?: any): Observable<Settings> {
        return this.duplicateSettingsWithHttpInfo(originalSettingsId, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Before a Category can be connected to an INSTANCE of a class it must be enabled to the class, thus a list of categories can be easily filtered by the context of the class at hand, the CategoryID to be enabled is passed as the entity in the Post request(!)
     * @summary Enable Category on Class
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.User&#39; 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public enableCategory(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.enableCategoryWithHttpInfo(className, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * exports to file 
     * @summary export baseclass
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public exportBaseclass(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.exportBaseclassWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * export Settings
     * @summary export settings
     * @param settingsId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public exportSettings(settingsId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.exportSettingsWithHttpInfo(settingsId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public fileResourcesOfType(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Array<FileResource>> {
        return this.fileResourcesOfTypeWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * finalize FileResource , sending it for processing
     * @summary finalize
     * @param md5 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param hint 
     * @param fileType 
     * @param dontProcess 
     */
    public finalizeUpload(md5: string, authenticationkey?: string, hint?: string, fileType?: string, dontProcess?: boolean, extraHttpRequestParams?: any): Observable<Job> {
        return this.finalizeUploadWithHttpInfo(md5, authenticationkey, hint, fileType, dontProcess, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Find an entity by Id and type, returns null if not found
     * @summary find entity by id and class
     * @param id The ID of the entity required
     * @param classname The canonical classname of the required entity
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findById(id: string, classname: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Baseclass> {
        return this.findByIdWithHttpInfo(id, classname, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Find an instance of a Baseclass extender by its id, returns an instance of a Baseclass
     * @summary Find an instance by ID
     * @param ID The id of instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findById_3(ID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Baseclass> {
        return this.findById_3WithHttpInfo(ID, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findById_4(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Role> {
        return this.findById_4WithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * returns a list of instances of the type requested
     * @summary Find an instance by its name
     * @param name The name of instance to be found
     * @param classname The cannonical classname of the instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findByName(name: string, classname: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.findByNameWithHttpInfo(name, classname, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     */
    public findBySidesId(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.findBySidesIdWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinks(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Baselink>> {
        return this.findLinksWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksContainers(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<LinkContainer>> {
        return this.findLinksContainersWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksValues(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.findLinksValuesWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param clientType 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view 
     */
    public generateClient(clientType: string, authenticationkey?: string, view?: string, extraHttpRequestParams?: any): Observable<Job> {
        return this.generateClientWithHttpInfo(clientType, authenticationkey, view, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param targetDevice 
     */
    public get(id: string, authenticationkey?: string, targetDevice?: string, extraHttpRequestParams?: any): Observable<Media> {
        return this.getWithHttpInfo(id, authenticationkey, targetDevice, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Get a list of all Categories whose name starts with the supplied string
     * @summary Get a list of Categories  by name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getAllCategories(authenticationkey?: string, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Category>> {
        return this.getAllCategoriesWithHttpInfo(authenticationkey, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Get a list of all Categories that are connected to an instance
     * @summary List Categories  by Instance
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllCategoriesConnected(baseId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.getAllCategoriesConnectedWithHttpInfo(baseId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllFileTypes(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<FileType>> {
        return this.getAllFileTypesWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Get a list of all Operations defined for the this Class, Some Operations have meaning with some Classes only
     * @summary Get all Operations
     * @param clazzName The canonical classname of the link required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllOperations(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Operation>> {
        return this.getAllOperationsWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * returns a list of views
     * @summary 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllViews(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<View>> {
        return this.getAllViewsWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Returns a list of ClazzLinkContainer instances of the given link(!) canonical name
     * @summary Get a list of all associations 
     * @param clazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAssociations(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<ClazzLinkContainer>> {
        return this.getAssociationsWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Get a list of all Categories that can be used (previously enabled) by a Class
     * @summary List Categories  by Class
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.media.Media&#39; will retrieve only Categories that can be used with a Media Object(Instance)
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getCategory(className: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Category>> {
        return this.getCategoryWithHttpInfo(className, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Get a list of all Categories whose name starts with the supplied string
     * @summary Get a list of Categories  by name
     * @param name A string that must match the left characters of a retrieved Category name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getCategoryByName(name: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Category>> {
        return this.getCategoryByNameWithHttpInfo(name, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Return a concrete instance of type Clazz, every type in the system including those created by Plug-ins have a concrete instance of Clazz type describing it.
     * @summary Get a Clazz instance from a canonical name
     * @param clazzName The canonical classname for which the instance is required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getClazz(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Clazz> {
        return this.getClazzWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getClients(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.getClientsWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getConnected(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.getConnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * update device used properties
     * @summary getDeviceUsedProperties
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public getDeviceUsedProperties(mac: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Array<DevicePropertyContainerObject>> {
        return this.getDeviceUsedPropertiesWithHttpInfo(mac, authenticationkey, body, pagesize, currentPage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param wantedClazzName 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getDisconnected(id: string, wantedClazzName: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.getDisconnectedWithHttpInfo(id, wantedClazzName, linkClazzName, authenticationkey, body, pagesize, currentpage, valueId, simpleValue, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view 
     */
    public getDocs(authenticationkey: string, view?: string, extraHttpRequestParams?: any): Observable<string> {
        return this.getDocsWithHttpInfo(authenticationkey, view, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * get all properties connected to baseclass
     * @summary get Connected Properties
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyClazz 
     * @param plainView 
     */
    public getDynamicProperties(id: string, authenticationkey?: string, propertyClazz?: string, plainView?: boolean, extraHttpRequestParams?: any): Observable<Array<PropertyContainerSerializable>> {
        return this.getDynamicPropertiesWithHttpInfo(id, authenticationkey, propertyClazz, plainView, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * get all properties connected to baseclass
     * @summary get Connected Properties With Categories
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyClazz 
     * @param plainView 
     */
    public getDynamicPropertiesWithCategories(id: string, authenticationkey?: string, propertyClazz?: string, plainView?: boolean, extraHttpRequestParams?: any): Observable<Array<PropertyContainerSerializable>> {
        return this.getDynamicPropertiesWithCategoriesWithHttpInfo(id, authenticationkey, propertyClazz, plainView, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public getFeatures(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Array<LicensingFeature>> {
        return this.getFeaturesWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * get a list of all FieldContainers per class, use it for the creation of a new instance and for updating one
     * @summary Get Field Containers per class
     * @param clazzName The canonical name of the Class for which the list is to be obtained
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getFields(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<FieldContainer>> {
        return this.getFieldsWithHttpInfo(clazzName, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param className 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getFields_5(className: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.getFields_5WithHttpInfo(className, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param md5 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getFileResource(md5: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.getFileResourceWithHttpInfo(md5, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param jobID 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getJob(jobID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Job> {
        return this.getJobWithHttpInfo(jobID, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public getOffsetInfo(authenticationkey?: string, body?: UpdateBundle, extraHttpRequestParams?: any): Observable<UpdateBundle> {
        return this.getOffsetInfoWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getPreview(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.getPreviewWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public getProducts(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Array<LicensingProduct>> {
        return this.getProductsWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param grouping 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param sortby 
     */
    public getRenderingBundles(grouping: string, id: string, authenticationkey?: string, pagesize?: number, currentpage?: number, sortby?: string, extraHttpRequestParams?: any): Observable<Array<FileResourceBundleHolder>> {
        return this.getRenderingBundlesWithHttpInfo(grouping, id, authenticationkey, pagesize, currentpage, sortby, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * create Settings
     * @summary create settings
     * @param settingsId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getSettings(settingsId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<SettingsContainer> {
        return this.getSettingsWithHttpInfo(settingsId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view 
     */
    public getSwaggerJSON(authenticationkey: string, view?: string, extraHttpRequestParams?: any): Observable<string> {
        return this.getSwaggerJSONWithHttpInfo(authenticationkey, view, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param apiKey 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getTenant(apiKey: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Tenant> {
        return this.getTenantWithHttpInfo(apiKey, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getTenants(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Tenant>> {
        return this.getTenantsWithHttpInfo(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param viewId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getViewClazzes(viewId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Clazz>> {
        return this.getViewClazzesWithHttpInfo(viewId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * import baseclass
     * @summary import baseclass
     * @param className 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public importBaseclass(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.importBaseclassWithHttpInfo(className, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * import Settings
     * @summary import settings
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param byName 
     * @param dontUpdate 
     */
    public importSettings(authenticationkey?: string, body?: SettingsContainer, byName?: boolean, dontUpdate?: boolean, extraHttpRequestParams?: any): Observable<boolean> {
        return this.importSettingsWithHttpInfo(authenticationkey, body, byName, dontUpdate, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public invalidateCache(authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.invalidateCacheWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param leftId 
     * @param rightId 
     * @param operationId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public linkBaseclassTouser(leftId: string, rightId: string, operationId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.linkBaseclassTouserWithHttpInfo(leftId, rightId, operationId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Helper class for linking Role and User using a RoleUserContainer class, can be carried out by using the Generic createBaselink call
     * @summary Link Role and User
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public linkroleuser(authenticationkey?: string, body?: RoleUserContainer, extraHttpRequestParams?: any): Observable<RoleToUser> {
        return this.linkroleuserWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param sortby 
     */
    public listAll(authenticationkey?: string, pagesize?: number, currentpage?: number, sortby?: string, extraHttpRequestParams?: any): Observable<Array<Media>> {
        return this.listAllWithHttpInfo(authenticationkey, pagesize, currentpage, sortby, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * lists all media that suites Filtering information holder
     * @summary fileResourcesInMediaByGroup
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param group 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public listAllFileResourcesOfGroupInMedia(id: string, authenticationkey?: string, group?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Array<FileResource>> {
        return this.listAllFileResourcesOfGroupInMediaWithHttpInfo(id, authenticationkey, group, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * returns all the file resources of the given types that are connected to the given Media
     * @summary get file resources
     * @param mediaId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public listAllFileResourcesOfType(mediaId: string, authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Array<FileResource>> {
        return this.listAllFileResourcesOfTypeWithHttpInfo(mediaId, authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listAllLoadedPlugins(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<PluginInformationHolder>> {
        return this.listAllLoadedPluginsWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public listAllRoles(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Role>> {
        return this.listAllRolesWithHttpInfo(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * lists all settings
     * @summary lists all Settings
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public listAllSettings(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Settings>> {
        return this.listAllSettingsWithHttpInfo(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * lists all settings metadata
     * @summary lists all Settings Metadata
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public listAllSettingsMetadata(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<SettingsMetadata>> {
        return this.listAllSettingsMetadataWithHttpInfo(authenticationkey, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listAllUserRoles(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Role>> {
        return this.listAllUserRolesWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public listAllUsers(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Array<UserClass>> {
        return this.listAllUsersWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * lists all media that suites Filtering information holder
     * @summary 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public listAllofType(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Array<Media>> {
        return this.listAllofTypeWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * list device Settings
     * @summary listDeviceSettingss
     * @param deviceId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listDeviceSettings(deviceId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<DeviceSettingsContainer>> {
        return this.listDeviceSettingsWithHttpInfo(deviceId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * list device Settings containers
     * @summary listDeviceSettingsContainers
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listDeviceSettingsContainers(mac: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<SettingsContainer>> {
        return this.listDeviceSettingsContainersWithHttpInfo(mac, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listDevices(authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Array<Device>> {
        return this.listDevicesWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * list heap dumps
     * @summary listHeapDumps
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param start 
     */
    public listHeapDumps(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, start?: number, extraHttpRequestParams?: any): Observable<Array<FileResource>> {
        return this.listHeapDumpsWithHttpInfo(authenticationkey, body, pagesize, currentpage, start, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * lists license requests
     * @summary 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public listLicenseRequest(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Array<LicenseRequest>> {
        return this.listLicenseRequestWithHttpInfo(authenticationkey, pagesize, currentpage, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * get all Properties, paged, filtered and sorted by a FilteringInformationHolder
     * @summary listProperties
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listProperties(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Array<Property>> {
        return this.listPropertiesWithHttpInfo(authenticationkey, body, pagesize, currentPage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * get all property types, filtered and sorted
     * @summary listPropertyTypes
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listPropertyTypes(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Array<PropertyType>> {
        return this.listPropertyTypesWithHttpInfo(authenticationkey, body, pagesize, currentPage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * lists settings
     * @summary lists Settings
     * @param settingsMetadataId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public listSettings(settingsMetadataId: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Settings>> {
        return this.listSettingsWithHttpInfo(settingsMetadataId, authenticationkey, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param email 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public lookupUserByEmail(email: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<UserClass> {
        return this.lookupUserByEmailWithHttpInfo(email, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public lookupUserById(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<UserClass> {
        return this.lookupUserByIdWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param number 
     */
    public multipleCreate(authenticationkey?: string, number?: number, extraHttpRequestParams?: any): Observable<number> {
        return this.multipleCreateWithHttpInfo(authenticationkey, number, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * returns a list of instances of the type requested
     * @summary Find an instance by its name with wildcard
     * @param classname The canonical classname of the required entity list
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public nameLike(classname: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.nameLikeWithHttpInfo(classname, authenticationkey, body, pagesize, currentpage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     */
    public ping(extraHttpRequestParams?: any): Observable<boolean> {
        return this.pingWithHttpInfo(extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * registers components if not exists and returns allowed
     * @summary registerAndGetAllowedUIComponents
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public registerAndGetAllowedUIComponents(authenticationkey?: string, body?: UIComponentsRegistrationContainer, extraHttpRequestParams?: any): Observable<Array<UIComponent>> {
        return this.registerAndGetAllowedUIComponentsWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path 
     * @param calcMd5 
     */
    public registerFile(authenticationkey?: string, path?: string, calcMd5?: boolean, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.registerFileWithHttpInfo(authenticationkey, path, calcMd5, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path 
     * @param hint 
     * @param fileType 
     * @param dontProcess 
     * @param calcMd5 
     */
    public registerFileAndFinlize(authenticationkey?: string, path?: string, hint?: string, fileType?: string, dontProcess?: boolean, calcMd5?: boolean, extraHttpRequestParams?: any): Observable<Job> {
        return this.registerFileAndFinlizeWithHttpInfo(authenticationkey, path, hint, fileType, dontProcess, calcMd5, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }



    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public restart(authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.restartWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * sets active settings for settingsMetadata
     * @summary setsActiveSettings
     * @param settingsMetaId 
     * @param settingId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public setActiveSettings(settingsMetaId: string, settingId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.setActiveSettingsWithHttpInfo(settingsMetaId, settingId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * sets active settings for settingsMetadata as null(using default values)
     * @summary setActiveSettingsAsDefault
     * @param settingsMetaId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public setActiveSettingsAsDefault(settingsMetaId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.setActiveSettingsAsDefaultWithHttpInfo(settingsMetaId, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * update device used properties
     * @summary setDeviceUsedProperties
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public setDeviceUsedProperties(mac: string, authenticationkey?: string, body?: DeviceUsedPropertiesContainer, extraHttpRequestParams?: any): Observable<{}> {
        return this.setDeviceUsedPropertiesWithHttpInfo(mac, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Sets Link as Updated
     * @summary setLinkUpdateDate
     * @param linkId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param date 
     */
    public setLinkUpdateDate(linkId: string, authenticationkey?: string, date?: Date, extraHttpRequestParams?: any): Observable<{}> {
        return this.setLinkUpdateDateWithHttpInfo(linkId, authenticationkey, date, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * set Property to use with specific Clazz, a Clazz is an Entity in FlexiCore, the PropertySetContainer has the required default values for both simple and complex values
     * @summary set Property
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public setProperty(authenticationkey?: string, body?: PropertySetContainerBaseclass, extraHttpRequestParams?: any): Observable<PropertyToClazz> {
        return this.setPropertyWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * soft delete baseclass
     * @summary softDelete
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public softDelete(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.softDeleteWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param jobID 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public stopJob(jobID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.stopJobWithHttpInfo(jobID, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public testUpdate(authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.testUpdateWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Update an instance,retrieve the related fields first, create BaseclassUpdateContainer with required fields
     * @summary Update an instance of a Baseclass extender
     * @param id 
     * @param clazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public update(id: string, clazzName: string, authenticationkey?: string, body?: BaseclassUpdateContainer, extraHttpRequestParams?: any): Observable<boolean> {
        return this.updateWithHttpInfo(id, clazzName, authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * Update an instance of a Baseclass using a BasicContainer instance 
     * @summary Update basic data
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public updateBasicDetails(authenticationkey?: string, body?: BasicContainer, extraHttpRequestParams?: any): Observable<boolean> {
        return this.updateBasicDetailsWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param jobID 
     * @param phaseName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateJobPhase(jobID: string, phaseName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateJobPhaseWithHttpInfo(jobID, phaseName, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param jobID 
     * @param key 
     * @param value 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateJobProperty(jobID: string, key: string, value: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateJobPropertyWithHttpInfo(jobID, key, value, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * update metadata property
     * @summary update metadata property
     * @param linkId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param simpleValue 
     */
    public updateMetadataSimple(linkId: string, authenticationkey?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<PropertyToSettingsMetadata> {
        return this.updateMetadataSimpleWithHttpInfo(linkId, authenticationkey, simpleValue, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * update Simple value of a Dynamic Property of a Baseclass instance
     * @summary updateSimple
     * @param linkId The link id (of PropertyToBaseclass type)
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param simpleValue The value to update
     */
    public updateSimple(linkId: string, authenticationkey?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<PropertyToBaseclass> {
        return this.updateSimpleWithHttpInfo(linkId, authenticationkey, simpleValue, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param updateTo 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateVersion(id: string, updateTo: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateVersionWithHttpInfo(id, updateTo, authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public update_6(authenticationkey?: string, body?: Media, extraHttpRequestParams?: any): Observable<{}> {
        return this.update_6WithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public uploadFileMulti(authenticationkey?: string, body?: MultipartFormDataInput, extraHttpRequestParams?: any): Observable<Array<FileResource>> {
        return this.uploadFileMultiWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public validate(authenticationkey?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.validateWithHttpInfo(authenticationkey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }


    /**
     * activateLink
     * activate a link between a device and baseclass
     * @param baseId 
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public activateLinkWithHttpInfo(baseId: string, mac: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/activateLink/${mac}/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId))
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling activateLink.');
        }
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling activateLink.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param roleId 
     * @param userId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public addUserToRoleWithHttpInfo(roleId: string, userId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/addToRole/${roleId}/${userId}'
            .replace('${' + 'roleId' + '}', String(roleId))
            .replace('${' + 'userId' + '}', String(userId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'roleId' is not null or undefined
        if (roleId === null || roleId === undefined) {
            throw new Error('Required parameter roleId was null or undefined when calling addUserToRole.');
        }
        // verify required parameter 'userId' is not null or undefined
        if (userId === null || userId === undefined) {
            throw new Error('Required parameter userId was null or undefined when calling addUserToRole.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param crtId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public attachCertificateWithHttpInfo(id: string, crtId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/license/attachCertificate/${id}/${crtId}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'crtId' + '}', String(crtId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling attachCertificate.');
        }
        // verify required parameter 'crtId' is not null or undefined
        if (crtId === null || crtId === undefined) {
            throw new Error('Required parameter crtId was null or undefined when calling attachCertificate.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * attach file resource
     * attachs a file resource to the given media , using primary bundle
     * @param mediaId 
     * @param fileResourceId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param group 
     */
    public attachFileResourceWithHttpInfo(mediaId: string, fileResourceId: string, authenticationkey?: string, group?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/attachFileResource/${media_id}/${fileResource_id}'
            .replace('${' + 'media_id' + '}', String(mediaId))
            .replace('${' + 'fileResource_id' + '}', String(fileResourceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mediaId' is not null or undefined
        if (mediaId === null || mediaId === undefined) {
            throw new Error('Required parameter mediaId was null or undefined when calling attachFileResource.');
        }
        // verify required parameter 'fileResourceId' is not null or undefined
        if (fileResourceId === null || fileResourceId === undefined) {
            throw new Error('Required parameter fileResourceId was null or undefined when calling attachFileResource.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (group !== undefined && group !== null) {
            headers.set('group', String(group));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * attach Property to metadata
     * attach Property to metadata
     * @param settingsMetaId 
     * @param propertyId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     */
    public attachPropertyToMetadataWithHttpInfo(settingsMetaId: string, propertyId: string, authenticationkey?: string, value?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/attachPropertyToMetadata/${settingsMetaId}/${propertyId}'
            .replace('${' + 'settingsMetaId' + '}', String(settingsMetaId))
            .replace('${' + 'propertyId' + '}', String(propertyId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'settingsMetaId' is not null or undefined
        if (settingsMetaId === null || settingsMetaId === undefined) {
            throw new Error('Required parameter settingsMetaId was null or undefined when calling attachPropertyToMetadata.');
        }
        // verify required parameter 'propertyId' is not null or undefined
        if (propertyId === null || propertyId === undefined) {
            throw new Error('Required parameter propertyId was null or undefined when calling attachPropertyToMetadata.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public attachTenantWithHttpInfo(authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/attachTennat';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param fileResourceId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public changeMediaPrimaryFileResourceBundleWithHttpInfo(id: string, fileResourceId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/${id}/${fileResourceId}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'fileResourceId' + '}', String(fileResourceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling changeMediaPrimaryFileResourceBundle.');
        }
        // verify required parameter 'fileResourceId' is not null or undefined
        if (fileResourceId === null || fileResourceId === undefined) {
            throw new Error('Required parameter fileResourceId was null or undefined when calling changeMediaPrimaryFileResourceBundle.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     */
    public checkDBAvailableWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/ping/checkDBAvailable';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Connect to Category
     * Connect a Category to an instance of any entity in the system
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param catId The ID of an existing Category
     */
    public connectCategoryWithHttpInfo(baseId: string, authenticationkey?: string, catId?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling connectCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (catId !== undefined && catId !== null) {
            headers.set('catId', String(catId));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * connectDeviceToBaseclass
     * Connect a Device to an instance of any entity in the system
     * @param baseId 
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param someHeader 
     */
    public connectDeviceToBaseclassWithHttpInfo(baseId: string, mac: string, authenticationkey?: string, someHeader?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/connectDeviceToBaseclass/${mac}/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId))
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling connectDeviceToBaseclass.');
        }
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling connectDeviceToBaseclass.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (someHeader !== undefined && someHeader !== null) {
            headers.set('someHeader', String(someHeader));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * connect Property
     * Connect a property and a baseclass with a complex type, this is the actual action of assigning a Complex Value of a property to a specific Baseclass , any Baseclasss
     * @param propertyId the ID of the Property instance to use
     * @param baseclassId The ID of the Baseclass to which we want to assign this complex value
     * @param valueId The ID of the ? extends Baseclass which is the complex value
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public connectPropertyComplexWithHttpInfo(propertyId: string, baseclassId: string, valueId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/connectComplex/${propertyId}/${baseclass_id}/${value_id}'
            .replace('${' + 'propertyId' + '}', String(propertyId))
            .replace('${' + 'baseclass_id' + '}', String(baseclassId))
            .replace('${' + 'value_id' + '}', String(valueId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'propertyId' is not null or undefined
        if (propertyId === null || propertyId === undefined) {
            throw new Error('Required parameter propertyId was null or undefined when calling connectPropertyComplex.');
        }
        // verify required parameter 'baseclassId' is not null or undefined
        if (baseclassId === null || baseclassId === undefined) {
            throw new Error('Required parameter baseclassId was null or undefined when calling connectPropertyComplex.');
        }
        // verify required parameter 'valueId' is not null or undefined
        if (valueId === null || valueId === undefined) {
            throw new Error('Required parameter valueId was null or undefined when calling connectPropertyComplex.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * connect Property
     * Connect property and a baseclass with simple value, assign a value of a Property to an instance of Baseclass, any Baseclass instance
     * @param propertyId The ID of the property, this Property must be connected eith the Clazz of the Baseclass in the baseclass_id parameter
     * @param baseclassId The Baseclass instance to which this value (for that property) is set
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param simpleValue The value to set, must be a String
     */
    public connectPropertySimpleWithHttpInfo(propertyId: string, baseclassId: string, authenticationkey?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/connectSimple/${propertyId}/${baseclass_id}'
            .replace('${' + 'propertyId' + '}', String(propertyId))
            .replace('${' + 'baseclass_id' + '}', String(baseclassId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'propertyId' is not null or undefined
        if (propertyId === null || propertyId === undefined) {
            throw new Error('Required parameter propertyId was null or undefined when calling connectPropertySimple.');
        }
        // verify required parameter 'baseclassId' is not null or undefined
        if (baseclassId === null || baseclassId === undefined) {
            throw new Error('Required parameter baseclassId was null or undefined when calling connectPropertySimple.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public connectToTenantWithHttpInfo(authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/connectToTenant';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param type 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public countWithHttpInfo(type: string, authenticationkey?: string, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/count/${type}'
            .replace('${' + 'type' + '}', String(type));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling count.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public countAllofTypeWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/count';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public countConnectedWithHttpInfo(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/countConnected/${wantedClazzName}/${id}/${linkClazzName}'
            .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling countConnected.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling countConnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling countConnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public countDisconnectedWithHttpInfo(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder,
        pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/countDisconnected/${wantedClazzName}/${id}/${linkClazzName}'
            .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling countDisconnected.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling countDisconnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling countDisconnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create an instance of a Baseclass extender
     * Creates a new instance of the requested Class, pass a properly initialized instance of BaseclassCreationContainer
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public createWithHttpInfo(authenticationkey?: string, body?: BaseclassCreationContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create a link
     * Creates a link between two instances in a generic way, provide values of the link
     * @param leftId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param rightId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value The ID of any instance inheriting from FC Baseclass, this effectively creates a triple link
     * @param simpleValue An explicit value of a string that can be part of the link
     * @param check If true, check if the link with these Left, Right and Complex Value values exists, if yes, then it will not be created
     */
    public createBaselinkWithHttpInfo(leftId: string, rightId: string, linkClazzName: string, authenticationkey?: string, value?: string, simpleValue?: string, check?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/${leftId}/${linkClazzName}/${rightId}'
            .replace('${' + 'leftId' + '}', String(leftId))
            .replace('${' + 'rightId' + '}', String(rightId))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'leftId' is not null or undefined
        if (leftId === null || leftId === undefined) {
            throw new Error('Required parameter leftId was null or undefined when calling createBaselink.');
        }
        // verify required parameter 'rightId' is not null or undefined
        if (rightId === null || rightId === undefined) {
            throw new Error('Required parameter rightId was null or undefined when calling createBaselink.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling createBaselink.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }

        if (check !== undefined && check !== null) {
            headers.set('check', String(check));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Create a Category
     * Return a single category
     * @param categoryName Inside a user interface categories are displayed by thier name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public createCategoryWithHttpInfo(categoryName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'categoryName' is not null or undefined
        if (categoryName === null || categoryName === undefined) {
            throw new Error('Required parameter categoryName was null or undefined when calling createCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (categoryName !== undefined && categoryName !== null) {
            headers.set('categoryName', String(categoryName));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * createDevice
     * creates a device
     * @param mac 
     * @param serialNumber 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param name 
     * @param lat 
     * @param lon 
     */
    public createDeviceWithHttpInfo(mac: string, serialNumber: string, authenticationkey?: string, name?: string, lat?: number,
        lon?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/createDevice/${mac}/${serialNumber}'
            .replace('${' + 'mac' + '}', String(mac))
            .replace('${' + 'serialNumber' + '}', String(serialNumber));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling createDevice.');
        }
        // verify required parameter 'serialNumber' is not null or undefined
        if (serialNumber === null || serialNumber === undefined) {
            throw new Error('Required parameter serialNumber was null or undefined when calling createDevice.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (name !== undefined && name !== null) {
            headers.set('name', String(name));
        }

        if (lat !== undefined && lat !== null) {
            headers.set('lat', String(lat));
        }

        if (lon !== undefined && lon !== null) {
            headers.set('lon', String(lon));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * createHeapDump
     * create heap dump
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path 
     */
    public createHeapDumpWithHttpInfo(authenticationkey?: string, pathparam?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/debug/createHeapDump';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (path !== undefined && path !== null) {
            headers.set('path', String(pathparam));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }



    /**
     * creates Property
     * creates a property given a type and a name, properties can be created and linked with Types. instances of these types can have associated values
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyName 
     * @param propertyType 
     */
    public createPropertyWithHttpInfo(authenticationkey?: string, propertyName?: string, propertyType?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (propertyName !== undefined && propertyName !== null) {
            headers.set('propertyName', String(propertyName));
        }

        if (propertyType !== undefined && propertyType !== null) {
            headers.set('propertyType', String(propertyType));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * creates Property Type
     * creates a property Type given  a name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyTypeName  the name of the property type to create
     */
    public createPropertyTypeWithHttpInfo(authenticationkey?: string, propertyTypeName?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/createType';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (propertyTypeName !== undefined && propertyTypeName !== null) {
            headers.set('propertyTypeName', String(propertyTypeName));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public createRoleWithHttpInfo(authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/roles';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * create settings
     * create Settings
     * @param settingsMetadataId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public createSettingsWithHttpInfo(settingsMetadataId: string, authenticationkey?: string, body?: SettingsMetadataCreationContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/createSettings/${settingsMetadataId}'
            .replace('${' + 'settingsMetadataId' + '}', String(settingsMetadataId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'settingsMetadataId' is not null or undefined
        if (settingsMetadataId === null || settingsMetadataId === undefined) {
            throw new Error('Required parameter settingsMetadataId was null or undefined when calling createSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * creates Settings Metadata
     * creates a settings metadata
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body Settings metadata container
     */
    public createSettingsMetadataWithHttpInfo(authenticationkey?: string, body?: SettingsMetadataCreationContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/new';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param tenantName 
     * @param apiKey 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public createTenantWithHttpInfo(tenantName: string, apiKey: string, authenticationkey?: string, body?: NewUser, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/tenant/${tenant_name}/${apiKey}'
            .replace('${' + 'tenant_name' + '}', String(tenantName))
            .replace('${' + 'apiKey' + '}', String(apiKey));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'tenantName' is not null or undefined
        if (tenantName === null || tenantName === undefined) {
            throw new Error('Required parameter tenantName was null or undefined when calling createTenant.');
        }
        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling createTenant.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param tenantName 
     * @param apiKey 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public createTenantNoUserWithHttpInfo(tenantName: string, apiKey: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/tenant/createTenantNoUser/${tenant_name}/${apiKey}'
            .replace('${' + 'tenant_name' + '}', String(tenantName))
            .replace('${' + 'apiKey' + '}', String(apiKey));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'tenantName' is not null or undefined
        if (tenantName === null || tenantName === undefined) {
            throw new Error('Required parameter tenantName was null or undefined when calling createTenantNoUser.');
        }
        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling createTenantNoUser.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * createUIInterface
     * creates UI interface
     * @param name 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public createUIInterfaceWithHttpInfo(name: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/uiPlugin/createUIInterface/${name}'
            .replace('${' + 'name' + '}', String(name));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling createUIInterface.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param loginuponsuccess 
     * @param body 
     */
    public createUserWithHttpInfo(authenticationkey?: string, loginuponsuccess?: boolean, body?: NewUserUserClass, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/new';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (loginuponsuccess !== undefined && loginuponsuccess !== null) {
            headers.set('loginuponsuccess', String(loginuponsuccess));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public create_1WithHttpInfo(authenticationkey?: string, body?: Media, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/new';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * deactivateAllLinks
     * deactivate all links between a device and baseclass
     * @param baseId 
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deactivateAllLinksWithHttpInfo(baseId: string, mac: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/deactivateAllLinks/${mac}/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId))
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling deactivateAllLinks.');
        }
        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling deactivateAllLinks.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * deactivateLink
     * deactivate link 
     * @param linkId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deactivateLinkWithHttpInfo(linkId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/deactivateLink/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling deactivateLink.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete
     * deletes an entity by id
     * @param id The id of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteByIdWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteById.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete
     * deletes an entity by id
     * @param id The id of the instance to be deleted
     * @param className The type of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteById_2WithHttpInfo(id: string, className: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/${class_name}/${id}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'class_name' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteById_2.');
        }
        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling deleteById_2.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param md5 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteFileResourceWithHttpInfo(md5: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/resources/${md5}'
            .replace('${' + 'md5' + '}', String(md5));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'md5' is not null or undefined
        if (md5 === null || md5 === undefined) {
            throw new Error('Required parameter md5 was null or undefined when calling deleteFileResource.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * deleteHeapDump
     * delete heap dump
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteHeapDumpWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/debug/deleteHeapDump/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteHeapDump.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteMediaWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteMedia.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Remove a link
     * Remove an existing link by the ID of its &#39;sides&#39;
     * @param leftId The ID of the left side of the link
     * @param rightId The ID of the right side of the link
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public detachEntitiesWithHttpInfo(leftId: string, rightId: string, linkClazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/${leftId}/${linkClazzName}/${rightId}'
            .replace('${' + 'leftId' + '}', String(leftId))
            .replace('${' + 'rightId' + '}', String(rightId))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'leftId' is not null or undefined
        if (leftId === null || leftId === undefined) {
            throw new Error('Required parameter leftId was null or undefined when calling detachEntities.');
        }
        // verify required parameter 'rightId' is not null or undefined
        if (rightId === null || rightId === undefined) {
            throw new Error('Required parameter rightId was null or undefined when calling detachEntities.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling detachEntities.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * device get settings
     * create Settings
     * @param settingsId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deviceGetSettingsWithHttpInfo(settingsId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/deviceGetSettings/${settingsId}'
            .replace('${' + 'settingsId' + '}', String(settingsId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'settingsId' is not null or undefined
        if (settingsId === null || settingsId === undefined) {
            throw new Error('Required parameter settingsId was null or undefined when calling deviceGetSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Disable Category on Class
     * Disable a previously disabled Category, the CategoryID to be enabled is passed as the entity in the Post request(!)
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.User&#39; 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public disableCategoryWithHttpInfo(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/${class_name}/disable'
            .replace('${' + 'class_name' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling disableCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Disconnect from Category
     * Disconnect a Category from an instance of a connected(to this Category) entity in the system
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass and connected to the specified Category
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param catId The ID of an existing Category
     */
    public disconnectCategoryWithHttpInfo(baseId: string, authenticationkey?: string, catId?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling disconnectCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (catId !== undefined && catId !== null) {
            headers.set('catId', String(catId));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param id id of the FileResource Object to Download
     */
    public downloadWithHttpInfo(authenticationkey: string, id: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/download/${authenticationkey}/${id}'
            .replace('${' + 'authenticationkey' + '}', String(authenticationkey))
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'authenticationkey' is not null or undefined
        if (authenticationkey === null || authenticationkey === undefined) {
            throw new Error('Required parameter authenticationkey was null or undefined when calling download.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling download.');
        }

        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * duplicate an entity, shallow by id 
     * duplicate an entity by Id , returns null if not successfully duplicated
     * @param id The ID of the entity required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public duplicateWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/clone/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling duplicate.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * duplicate settings
     * duplicate Settings
     * @param originalSettingsId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public duplicateSettingsWithHttpInfo(originalSettingsId: string, authenticationkey?: string, body?: SettingsMetadataCreationContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/duplicateSettings/${originalSettingsId}'
            .replace('${' + 'originalSettingsId' + '}', String(originalSettingsId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'originalSettingsId' is not null or undefined
        if (originalSettingsId === null || originalSettingsId === undefined) {
            throw new Error('Required parameter originalSettingsId was null or undefined when calling duplicateSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Enable Category on Class
     * Before a Category can be connected to an INSTANCE of a class it must be enabled to the class, thus a list of categories can be easily filtered by the context of the class at hand, the CategoryID to be enabled is passed as the entity in the Post request(!)
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.User&#39; 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public enableCategoryWithHttpInfo(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/enable/${class_name}'
            .replace('${' + 'class_name' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling enableCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * export baseclass
     * exports to file 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public exportBaseclassWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/exportBaseclass/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling exportBaseclass.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * export settings
     * export Settings
     * @param settingsId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public exportSettingsWithHttpInfo(settingsId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/exportSettings/${settingsId}'
            .replace('${' + 'settingsId' + '}', String(settingsId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'settingsId' is not null or undefined
        if (settingsId === null || settingsId === undefined) {
            throw new Error('Required parameter settingsId was null or undefined when calling exportSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public fileResourcesOfTypeWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/fileResourcesOfType';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * finalize
     * finalize FileResource , sending it for processing
     * @param md5 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param hint 
     * @param fileType 
     * @param dontProcess 
     */
    public finalizeUploadWithHttpInfo(md5: string, authenticationkey?: string, hint?: string, fileType?: string, dontProcess?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/resources/finalize/${md5}'
            .replace('${' + 'md5' + '}', String(md5));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'md5' is not null or undefined
        if (md5 === null || md5 === undefined) {
            throw new Error('Required parameter md5 was null or undefined when calling finalizeUpload.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (hint !== undefined && hint !== null) {
            headers.set('hint', String(hint));
        }

        if (fileType !== undefined && fileType !== null) {
            headers.set('fileType', String(fileType));
        }

        if (dontProcess !== undefined && dontProcess !== null) {
            headers.set('dontProcess', String(dontProcess));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * find entity by id and class
     * Find an entity by Id and type, returns null if not found
     * @param id The ID of the entity required
     * @param classname The canonical classname of the required entity
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findByIdWithHttpInfo(id: string, classname: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/getbyid/${id}/${classname}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findById.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findById.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Find an instance by ID
     * Find an instance of a Baseclass extender by its id, returns an instance of a Baseclass
     * @param ID The id of instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findById_3WithHttpInfo(ID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/${id}'
            .replace('${' + 'ID' + '}', String(ID));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'ID' is not null or undefined
        if (ID === null || ID === undefined) {
            throw new Error('Required parameter ID was null or undefined when calling findById_3.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findById_4WithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/roles/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findById_4.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Find an instance by its name
     * returns a list of instances of the type requested
     * @param name The name of instance to be found
     * @param classname The cannonical classname of the instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findByNameWithHttpInfo(name: string, classname: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/${name}/${classname}'
            .replace('${' + 'Name' + '}', String(name))
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling findByName.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findByName.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     */
    public findBySidesIdWithHttpInfo(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/${left}/${right}/${classname}'
            .replace('${' + 'left' + '}', String(left))
            .replace('${' + 'right' + '}', String(right))
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findBySidesId.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findBySidesId.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findBySidesId.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksWithHttpInfo(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/findLinks/${left}/${right}/${classname}'
            .replace('${' + 'left' + '}', String(left))
            .replace('${' + 'right' + '}', String(right))
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findLinks.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findLinks.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findLinks.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksContainersWithHttpInfo(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/findLinksContainers/${left}/${right}/${classname}'
            .replace('${' + 'left' + '}', String(left))
            .replace('${' + 'right' + '}', String(right))
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findLinksContainers.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findLinksContainers.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findLinksContainers.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksValuesWithHttpInfo(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/findLinksValues/${left}/${right}/${classname}'
            .replace('${' + 'left' + '}', String(left))
            .replace('${' + 'right' + '}', String(right))
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findLinksValues.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findLinksValues.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findLinksValues.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param clientType 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view 
     */
    public generateClientWithHttpInfo(clientType: string, authenticationkey?: string, view?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/swagger/extended/generateClient/${client_type}'
            .replace('${' + 'client_type' + '}', String(clientType));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'clientType' is not null or undefined
        if (clientType === null || clientType === undefined) {
            throw new Error('Required parameter clientType was null or undefined when calling generateClient.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (view !== undefined && view !== null) {
            headers.set('view', String(view));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param targetDevice 
     */
    public getWithHttpInfo(id: string, authenticationkey?: string, targetDevice?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling get.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (targetDevice !== undefined && targetDevice !== null) {
            headers.set('targetDevice', String(targetDevice));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get a list of Categories  by name
     * Get a list of all Categories whose name starts with the supplied string
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getAllCategoriesWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/getAll';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List Categories  by Instance
     * Get a list of all Categories that are connected to an instance
     * @param baseId The ID of an existing entity in the system, entity must inherit from FC Baseclass
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllCategoriesConnectedWithHttpInfo(baseId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/connected/${baseId}'
            .replace('${' + 'baseId' + '}', String(baseId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'baseId' is not null or undefined
        if (baseId === null || baseId === undefined) {
            throw new Error('Required parameter baseId was null or undefined when calling getAllCategoriesConnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllFileTypesWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/types';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get all Operations
     * Get a list of all Operations defined for the this Class, Some Operations have meaning with some Classes only
     * @param clazzName The canonical classname of the link required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllOperationsWithHttpInfo(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/clazz/operations/${clazzName}'
            .replace('${' + 'clazzName' + '}', String(clazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'clazzName' is not null or undefined
        if (clazzName === null || clazzName === undefined) {
            throw new Error('Required parameter clazzName was null or undefined when calling getAllOperations.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * returns a list of views
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAllViewsWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/view';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get a list of all associations 
     * Returns a list of ClazzLinkContainer instances of the given link(!) canonical name
     * @param clazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getAssociationsWithHttpInfo(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/clazz/associations/${clazzName}'
            .replace('${' + 'clazzName' + '}', String(clazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'clazzName' is not null or undefined
        if (clazzName === null || clazzName === undefined) {
            throw new Error('Required parameter clazzName was null or undefined when calling getAssociations.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * List Categories  by Class
     * Get a list of all Categories that can be used (previously enabled) by a Class
     * @param className the cannonical name of a Class of an Entity in the system, such Class must extend Baseclass, for Example: &#39;com.flexicore.model.media.Media&#39; will retrieve only Categories that can be used with a Media Object(Instance)
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getCategoryWithHttpInfo(className: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/${class_name}'
            .replace('${' + 'class_name' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling getCategory.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get a list of Categories  by name
     * Get a list of all Categories whose name starts with the supplied string
     * @param name A string that must match the left characters of a retrieved Category name
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getCategoryByNameWithHttpInfo(name: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/category/byname/${name}'
            .replace('${' + 'name' + '}', String(name));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling getCategoryByName.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get a Clazz instance from a canonical name
     * Return a concrete instance of type Clazz, every type in the system including those created by Plug-ins have a concrete instance of Clazz type describing it.
     * @param clazzName The canonical classname for which the instance is required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getClazzWithHttpInfo(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/clazz/${clazzName}'
            .replace('${' + 'clazzName' + '}', String(clazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'clazzName' is not null or undefined
        if (clazzName === null || clazzName === undefined) {
            throw new Error('Required parameter clazzName was null or undefined when calling getClazz.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getClientsWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/swagger/extended/clients';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getConnectedWithHttpInfo(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/connected/${wantedClazzName}/${id}/${linkClazzName}'
            .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling getConnected.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getConnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling getConnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * getDeviceUsedProperties
     * update device used properties
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public getDeviceUsedPropertiesWithHttpInfo(mac: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/getDeviceUsedProperties/${mac}'
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling getDeviceUsedProperties.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param wantedClazzName 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getDisconnectedWithHttpInfo(id: string, wantedClazzName: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, valueId?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/disconnected/${wantedClazzName}/${id}/${linkClazzName}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
            .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDisconnected.');
        }
        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling getDisconnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling getDisconnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view 
     */
    public getDocsWithHttpInfo(authenticationkey: string, view?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/swagger/extended/docs/${authenticationkey}'
            .replace('${' + 'authenticationkey' + '}', String(authenticationkey));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'authenticationkey' is not null or undefined
        if (authenticationkey === null || authenticationkey === undefined) {
            throw new Error('Required parameter authenticationkey was null or undefined when calling getDocs.');
        }
        if (view !== undefined && view !== null) {
            headers.set('view', String(view));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * get Connected Properties
     * get all properties connected to baseclass
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyClazz 
     * @param plainView 
     */
    public getDynamicPropertiesWithHttpInfo(id: string, authenticationkey?: string, propertyClazz?: string, plainView?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDynamicProperties.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (propertyClazz !== undefined && propertyClazz !== null) {
            headers.set('propertyClazz', String(propertyClazz));
        }

        if (plainView !== undefined && plainView !== null) {
            headers.set('plainView', String(plainView));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * get Connected Properties With Categories
     * get all properties connected to baseclass
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param propertyClazz 
     * @param plainView 
     */
    public getDynamicPropertiesWithCategoriesWithHttpInfo(id: string, authenticationkey?: string, propertyClazz?: string, plainView?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/getDynamicPropertiesWithCategories/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDynamicPropertiesWithCategories.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (propertyClazz !== undefined && propertyClazz !== null) {
            headers.set('propertyClazz', String(propertyClazz));
        }

        if (plainView !== undefined && plainView !== null) {
            headers.set('plainView', String(plainView));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public getFeaturesWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/license/getFeatures';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Get Field Containers per class
     * get a list of all FieldContainers per class, use it for the creation of a new instance and for updating one
     * @param clazzName The canonical name of the Class for which the list is to be obtained
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getFieldsWithHttpInfo(clazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/clazz/fields/${clazzName}'
            .replace('${' + 'clazzName' + '}', String(clazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'clazzName' is not null or undefined
        if (clazzName === null || clazzName === undefined) {
            throw new Error('Required parameter clazzName was null or undefined when calling getFields.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param className 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getFields_5WithHttpInfo(className: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/${class_name}/fields'
            .replace('${' + 'class_name' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling getFields_5.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param md5 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getFileResourceWithHttpInfo(md5: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/resources/${md5}'
            .replace('${' + 'md5' + '}', String(md5));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'md5' is not null or undefined
        if (md5 === null || md5 === undefined) {
            throw new Error('Required parameter md5 was null or undefined when calling getFileResource.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param jobID 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getJobWithHttpInfo(jobID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/jobProcess/${jobID}'
            .replace('${' + 'jobID' + '}', String(jobID));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'jobID' is not null or undefined
        if (jobID === null || jobID === undefined) {
            throw new Error('Required parameter jobID was null or undefined when calling getJob.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public getOffsetInfoWithHttpInfo(authenticationkey?: string, body?: UpdateBundle, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getPreviewWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/${id}/preview'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPreview.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public getProductsWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/license/getProducts';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param grouping 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param sortby 
     */
    public getRenderingBundlesWithHttpInfo(grouping: string, id: string, authenticationkey?: string, pagesize?: number, currentpage?: number, sortby?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/bundles/${grouping}/${id}'
            .replace('${' + 'grouping' + '}', String(grouping))
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'grouping' is not null or undefined
        if (grouping === null || grouping === undefined) {
            throw new Error('Required parameter grouping was null or undefined when calling getRenderingBundles.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getRenderingBundles.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }

        if (sortby !== undefined && sortby !== null) {
            headers.set('sortby', String(sortby));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * create settings
     * create Settings
     * @param settingsId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getSettingsWithHttpInfo(settingsId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/${settingsId}'
            .replace('${' + 'settingsId' + '}', String(settingsId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'settingsId' is not null or undefined
        if (settingsId === null || settingsId === undefined) {
            throw new Error('Required parameter settingsId was null or undefined when calling getSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param view 
     */
    public getSwaggerJSONWithHttpInfo(authenticationkey: string, view?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/swagger/extended/swagger.json/${authenticationkey}'
            .replace('${' + 'authenticationkey' + '}', String(authenticationkey));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'authenticationkey' is not null or undefined
        if (authenticationkey === null || authenticationkey === undefined) {
            throw new Error('Required parameter authenticationkey was null or undefined when calling getSwaggerJSON.');
        }
        if (view !== undefined && view !== null) {
            headers.set('view', String(view));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param apiKey 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getTenantWithHttpInfo(apiKey: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/tenant/${apiKey}'
            .replace('${' + 'apiKey' + '}', String(apiKey));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'apiKey' is not null or undefined
        if (apiKey === null || apiKey === undefined) {
            throw new Error('Required parameter apiKey was null or undefined when calling getTenant.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getTenantsWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/tenant';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param viewId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public getViewClazzesWithHttpInfo(viewId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/view/clazzes/${viewId}'
            .replace('${' + 'viewId' + '}', String(viewId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'viewId' is not null or undefined
        if (viewId === null || viewId === undefined) {
            throw new Error('Required parameter viewId was null or undefined when calling getViewClazzes.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * import baseclass
     * import baseclass
     * @param className 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public importBaseclassWithHttpInfo(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/importBaseclass/${className}'
            .replace('${' + 'className' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling importBaseclass.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * import settings
     * import Settings
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param byName 
     * @param dontUpdate 
     */
    public importSettingsWithHttpInfo(authenticationkey?: string, body?: SettingsContainer, byName?: boolean, dontUpdate?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/importSettings';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (byName !== undefined && byName !== null) {
            headers.set('byName', String(byName));
        }

        if (dontUpdate !== undefined && dontUpdate !== null) {
            headers.set('dontUpdate', String(dontUpdate));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public invalidateCacheWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/swagger/extended/invalidateCache';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param leftId 
     * @param rightId 
     * @param operationId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public linkBaseclassTouserWithHttpInfo(leftId: string, rightId: string, operationId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/linkUserToBaseclass/${left_id}/${right_id}/${operation_id}'
            .replace('${' + 'left_id' + '}', String(leftId))
            .replace('${' + 'right_id' + '}', String(rightId))
            .replace('${' + 'operation_id' + '}', String(operationId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'leftId' is not null or undefined
        if (leftId === null || leftId === undefined) {
            throw new Error('Required parameter leftId was null or undefined when calling linkBaseclassTouser.');
        }
        // verify required parameter 'rightId' is not null or undefined
        if (rightId === null || rightId === undefined) {
            throw new Error('Required parameter rightId was null or undefined when calling linkBaseclassTouser.');
        }
        // verify required parameter 'operationId' is not null or undefined
        if (operationId === null || operationId === undefined) {
            throw new Error('Required parameter operationId was null or undefined when calling linkBaseclassTouser.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Link Role and User
     * Helper class for linking Role and User using a RoleUserContainer class, can be carried out by using the Generic createBaselink call
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public linkroleuserWithHttpInfo(authenticationkey?: string, body?: RoleUserContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/linkroleuser';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param sortby 
     */
    public listAllWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, sortby?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }

        if (sortby !== undefined && sortby !== null) {
            headers.set('sortby', String(sortby));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * fileResourcesInMediaByGroup
     * lists all media that suites Filtering information holder
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param group 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public listAllFileResourcesOfGroupInMediaWithHttpInfo(id: string, authenticationkey?: string, group?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/list/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listAllFileResourcesOfGroupInMedia.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (group !== undefined && group !== null) {
            headers.set('group', String(group));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * get file resources
     * returns all the file resources of the given types that are connected to the given Media
     * @param mediaId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public listAllFileResourcesOfTypeWithHttpInfo(mediaId: string, authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/fileResources/${media_id}'
            .replace('${' + 'media_id' + '}', String(mediaId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mediaId' is not null or undefined
        if (mediaId === null || mediaId === undefined) {
            throw new Error('Required parameter mediaId was null or undefined when calling listAllFileResourcesOfType.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listAllLoadedPluginsWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public listAllRolesWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/roles/list';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * lists all Settings
     * lists all settings
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public listAllSettingsWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/listAllSettings';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * lists all Settings Metadata
     * lists all settings metadata
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public listAllSettingsMetadataWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listAllUserRolesWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/roles/userRoles/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listAllUserRoles.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public listAllUsersWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * lists all media that suites Filtering information holder
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public listAllofTypeWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * listDeviceSettingss
     * list device Settings
     * @param deviceId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listDeviceSettingsWithHttpInfo(deviceId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/listDeviceSettings/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling listDeviceSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * listDeviceSettingsContainers
     * list device Settings containers
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public listDeviceSettingsContainersWithHttpInfo(mac: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/listDeviceSettingsContainers/${mac}'
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling listDeviceSettingsContainers.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listDevicesWithHttpInfo(authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/listDevices';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * listHeapDumps
     * list heap dumps
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param start 
     */
    public listHeapDumpsWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, start?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/debug/listHeapDumps';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }

        if (start !== undefined && start !== null) {
            headers.set('start', String(start));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * lists license requests
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body filtering information
     */
    public listLicenseRequestWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/license/listAll';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * listProperties
     * get all Properties, paged, filtered and sorted by a FilteringInformationHolder
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listPropertiesWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/listProperties';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * listPropertyTypes
     * get all property types, filtered and sorted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listPropertyTypesWithHttpInfo(authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/listPropertyTypes';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * lists Settings
     * lists settings
     * @param settingsMetadataId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public listSettingsWithHttpInfo(settingsMetadataId: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/listSettings/${settingsMetadataId}'
            .replace('${' + 'settingsMetadataId' + '}', String(settingsMetadataId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'settingsMetadataId' is not null or undefined
        if (settingsMetadataId === null || settingsMetadataId === undefined) {
            throw new Error('Required parameter settingsMetadataId was null or undefined when calling listSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * listUIInterfaces
     * lists ui interfaces
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public listUIInterfacesWithHttpInfo(authenticationkey?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/uiPlugin/listUIInterfaces';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * listUIPluginsByInterface
     * lists plugin by interface
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param interfaceId 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     * @param body 
     */
    public listUIPluginsByInterfaceWithHttpInfo(authenticationkey?: string, interfaceId?: string, pagesize?: number, currentpage?: number, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/uiPlugin/listUIPluginsByInterface/${interfaceId}';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (interfaceId !== undefined && interfaceId !== null) {
            headers.set('interfaceId', String(interfaceId));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param email 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public lookupUserByEmailWithHttpInfo(email: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/byEmail/${email}'
            .replace('${' + 'email' + '}', String(email));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'email' is not null or undefined
        if (email === null || email === undefined) {
            throw new Error('Required parameter email was null or undefined when calling lookupUserByEmail.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public lookupUserByIdWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/byId/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling lookupUserById.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param number 
     */
    public multipleCreateWithHttpInfo(authenticationkey?: string, number?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/users/batchCreate';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (number !== undefined && number !== null) {
            headers.set('number', String(number));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Find an instance by its name with wildcard
     * returns a list of instances of the type requested
     * @param classname The canonical classname of the required entity list
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public nameLikeWithHttpInfo(classname: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/like/name/${classname}'
            .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling nameLike.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     */
    public pingWithHttpInfo(extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/ping';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * registerAndGetAllowedUIComponents
     * registers components if not exists and returns allowed
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public registerAndGetAllowedUIComponentsWithHttpInfo(authenticationkey?: string, body?: UIComponentsRegistrationContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/uiPlugin/registerAndGetAllowedUIComponents';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path 
     * @param calcMd5 
     */
    public registerFileWithHttpInfo(authenticationkey?: string, pathparam?: string, calcMd5?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/resources/register';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (path !== undefined && path !== null) {
            headers.set('path', String(pathparam));
        }

        if (calcMd5 !== undefined && calcMd5 !== null) {
            headers.set('calcMd5', String(calcMd5));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param path 
     * @param hint 
     * @param fileType 
     * @param dontProcess 
     * @param calcMd5 
     */
    public registerFileAndFinlizeWithHttpInfo(authenticationkey?: string, pathparam?: string, hint?: string, fileType?: string, dontProcess?: boolean, calcMd5?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/resources/registerAndFinalize';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(pathparam));
        }

        if (path !== undefined && path !== null) {
            headers.set('path', String(path));
        }

        if (hint !== undefined && hint !== null) {
            headers.set('hint', String(hint));
        }

        if (fileType !== undefined && fileType !== null) {
            headers.set('fileType', String(fileType));
        }

        if (dontProcess !== undefined && dontProcess !== null) {
            headers.set('dontProcess', String(dontProcess));
        }

        if (calcMd5 !== undefined && calcMd5 !== null) {
            headers.set('calcMd5', String(calcMd5));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }


    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public restartWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * setsActiveSettings
     * sets active settings for settingsMetadata
     * @param settingsMetaId 
     * @param settingId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public setActiveSettingsWithHttpInfo(settingsMetaId: string, settingId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/setActiveSettings/${settingsMetaId}/${settingId}'
            .replace('${' + 'settingsMetaId' + '}', String(settingsMetaId))
            .replace('${' + 'settingId' + '}', String(settingId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'settingsMetaId' is not null or undefined
        if (settingsMetaId === null || settingsMetaId === undefined) {
            throw new Error('Required parameter settingsMetaId was null or undefined when calling setActiveSettings.');
        }
        // verify required parameter 'settingId' is not null or undefined
        if (settingId === null || settingId === undefined) {
            throw new Error('Required parameter settingId was null or undefined when calling setActiveSettings.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * setActiveSettingsAsDefault
     * sets active settings for settingsMetadata as null(using default values)
     * @param settingsMetaId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public setActiveSettingsAsDefaultWithHttpInfo(settingsMetaId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/setActiveSettingsAsDefault/${settingsMetaId}'
            .replace('${' + 'settingsMetaId' + '}', String(settingsMetaId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'settingsMetaId' is not null or undefined
        if (settingsMetaId === null || settingsMetaId === undefined) {
            throw new Error('Required parameter settingsMetaId was null or undefined when calling setActiveSettingsAsDefault.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * setDeviceUsedProperties
     * update device used properties
     * @param mac 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public setDeviceUsedPropertiesWithHttpInfo(mac: string, authenticationkey?: string, body?: DeviceUsedPropertiesContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/setDeviceUsedProperties/${mac}'
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling setDeviceUsedProperties.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * setLinkUpdateDate
     * Sets Link as Updated
     * @param linkId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param date 
     */
    public setLinkUpdateDateWithHttpInfo(linkId: string, authenticationkey?: string, date?: Date, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/device/setLinkUpdateDate/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling setLinkUpdateDate.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (date !== undefined && date !== null) {
            headers.set('date', String(date));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * set Property
     * set Property to use with specific Clazz, a Clazz is an Entity in FlexiCore, the PropertySetContainer has the required default values for both simple and complex values
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public setPropertyWithHttpInfo(authenticationkey?: string, body?: PropertySetContainerBaseclass, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/set';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * softDelete
     * soft delete baseclass
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public softDeleteWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/softDelete/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling softDelete.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param jobID 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public stopJobWithHttpInfo(jobID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/jobProcess/${jobID}'
            .replace('${' + 'jobID' + '}', String(jobID));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'jobID' is not null or undefined
        if (jobID === null || jobID === undefined) {
            throw new Error('Required parameter jobID was null or undefined when calling stopJob.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public testUpdateWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/testUpdate';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update an instance of a Baseclass extender
     * Update an instance,retrieve the related fields first, create BaseclassUpdateContainer with required fields
     * @param id 
     * @param clazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public updateWithHttpInfo(id: string, clazzName: string, authenticationkey?: string, body?: BaseclassUpdateContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/update/${clazz_name}/${id}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'clazz_name' + '}', String(clazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling update.');
        }
        // verify required parameter 'clazzName' is not null or undefined
        if (clazzName === null || clazzName === undefined) {
            throw new Error('Required parameter clazzName was null or undefined when calling update.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Update basic data
     * Update an instance of a Baseclass using a BasicContainer instance 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public updateBasicDetailsWithHttpInfo(authenticationkey?: string, body?: BasicContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param jobID 
     * @param phaseName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateJobPhaseWithHttpInfo(jobID: string, phaseName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/jobProcess/updateJobPhase/${jobID}/${phaseName}'
            .replace('${' + 'jobID' + '}', String(jobID))
            .replace('${' + 'phaseName' + '}', String(phaseName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'jobID' is not null or undefined
        if (jobID === null || jobID === undefined) {
            throw new Error('Required parameter jobID was null or undefined when calling updateJobPhase.');
        }
        // verify required parameter 'phaseName' is not null or undefined
        if (phaseName === null || phaseName === undefined) {
            throw new Error('Required parameter phaseName was null or undefined when calling updateJobPhase.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param jobID 
     * @param key 
     * @param value 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateJobPropertyWithHttpInfo(jobID: string, key: string, value: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/jobProcess/updateJobProperty/${jobID}/${key}/${value}'
            .replace('${' + 'jobID' + '}', String(jobID))
            .replace('${' + 'key' + '}', String(key))
            .replace('${' + 'value' + '}', String(value));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'jobID' is not null or undefined
        if (jobID === null || jobID === undefined) {
            throw new Error('Required parameter jobID was null or undefined when calling updateJobProperty.');
        }
        // verify required parameter 'key' is not null or undefined
        if (key === null || key === undefined) {
            throw new Error('Required parameter key was null or undefined when calling updateJobProperty.');
        }
        // verify required parameter 'value' is not null or undefined
        if (value === null || value === undefined) {
            throw new Error('Required parameter value was null or undefined when calling updateJobProperty.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * update metadata property
     * update metadata property
     * @param linkId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param simpleValue 
     */
    public updateMetadataSimpleWithHttpInfo(linkId: string, authenticationkey?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/settings/updateMetadataSimple/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling updateMetadataSimple.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * updateSimple
     * update Simple value of a Dynamic Property of a Baseclass instance
     * @param linkId The link id (of PropertyToBaseclass type)
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param simpleValue The value to update
     */
    public updateSimpleWithHttpInfo(linkId: string, authenticationkey?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/property/updateSimple/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling updateSimple.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param updateTo 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateVersionWithHttpInfo(id: string, updateTo: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media/updateVersion/${id}/${updateTo}'
            .replace('${' + 'id' + '}', String(id))
            .replace('${' + 'updateTo' + '}', String(updateTo));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateVersion.');
        }
        // verify required parameter 'updateTo' is not null or undefined
        if (updateTo === null || updateTo === undefined) {
            throw new Error('Required parameter updateTo was null or undefined when calling updateVersion.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public update_6WithHttpInfo(authenticationkey?: string, body?: Media, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/media';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public uploadFileMultiWithHttpInfo(authenticationkey?: string, body?: MultipartFormDataInput, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/resources/upload';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public validateWithHttpInfo(authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/resources/validate';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
