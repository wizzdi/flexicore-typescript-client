/**
 * REST API for Flexicore filtered by your access rights
 * Flexicore REST API
 *
 * OpenAPI spec version: V1.1.0
 * Contact: avishaybennatan@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { FlexiCoreDecycle }                      from './flexiCoreDecycle';
import { Http, Headers, URLSearchParams }                    from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response, ResponseContentType }                     from '@angular/http';

import { Observable }                                        from 'rxjs/Observable';

import { Baseclass } from '../model/baseclass';
import { Baselink } from '../model/baselink';
import { BasicContainer } from '../model/basicContainer';
import { FileResource } from '../model/fileResource';
import { FilteringInformationHolder } from '../model/filteringInformationHolder';
import { LinkContainer } from '../model/linkContainer';
import { RoleToUser } from '../model/roleToUser';
import { RoleUserContainer } from '../model/roleUserContainer';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';
import { SetBaseclassTenantRequest, ParameterInfo, PaginationResponse } from '../model/models';
import { GetClassInfo } from '../model/getClassInfo';
import { ClassInfo } from '../model/classInfo';
import { ExportBaseclassGeneric } from '../model/exportBaseclassGeneric';
import { BasicDelete } from '../model/basicDelete';
import { BasicDeleteResponse } from '../model/basicDeleteResponse';


@Injectable()
export class BaseclassesService {

    protected basePath = 'https://192.168.0.41:8080/FlexiCore/rest';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
			this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * 
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    private extendObj<T1,T2>(objA: T1, objB: T2) {
        for(let key in objB){
            if(objB.hasOwnProperty(key)){
                (objA as any)[key] = (objB as any)[key];
            }
        }
        return <T1&T2>objA;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    /**
     * 
     * @param type 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public count(type: string, authenticationkey?: string, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<number> {
        return this.countWithHttpInfo(type, authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public countConnected(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number,valueId?:string,simpleValue?:string, extraHttpRequestParams?: any): Observable<number> {
        return this.countConnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage,valueId,simpleValue, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public countDisconnected(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number,valueId?:string,simpleValue?:string, extraHttpRequestParams?: any): Observable<number> {
        return this.countDisconnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage,valueId,simpleValue, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * Creates a link between two instances in a generic way, provide values of the link
     * @summary Create a link
     * @param leftId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param rightId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value The ID of any instance inheriting from FC Baseclass, this effectively creates a triple link
     * @param simpleValue An explicit value of a string that can be part of the link
     * @param check If true, check if the link with these Left, Right and Complex Value values exists, if yes, then it will not be created
     */
    public createBaselink(leftId: string, rightId: string, linkClazzName: string, authenticationkey?: string, value?: string, simpleValue?: string, check?: boolean, extraHttpRequestParams?: any): Observable<Baselink> {
        return this.createBaselinkWithHttpInfo(leftId, rightId, linkClazzName, authenticationkey, value, simpleValue, check, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * deletes an entity by id
     * @summary delete
     * @param id The id of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteById(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteByIdWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * deletes an entity by id
     * @summary delete
     * @param id The id of the instance to be deleted
     * @param className The type of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteById_1(id: string, className: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.deleteById_1WithHttpInfo(id, className, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Remove an existing link by the ID of its 'sides'
     * @summary Remove a link
     * @param leftId The ID of the left side of the link
     * @param rightId The ID of the right side of the link
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public detachEntities(leftId: string, rightId: string, linkClazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.detachEntitiesWithHttpInfo(leftId, rightId, linkClazzName, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * duplicate an entity by Id , returns null if not successfully duplicated
     * @summary duplicate an entity, shallow by id 
     * @param id The ID of the entity required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public duplicate(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Baseclass> {
        return this.duplicateWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * exports to file 
     * @summary export baseclass
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public exportBaseclass(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.exportBaseclassWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Find an entity by Id and type, returns null if not found
     * @summary find entity by id and class
     * @param id The ID of the entity required
     * @param classname The canonical classname of the required entity
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findById(id: string, classname: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Baseclass> {
        return this.findByIdWithHttpInfo(id, classname, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Find an instance of a Baseclass extender by its id, returns an instance of a Baseclass
     * @summary Find an instance by ID
     * @param ID The id of instance to be foundw
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findById_2(ID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Baseclass> {
        return this.findById_2WithHttpInfo(ID, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * returns a list of instances of the type requested
     * @summary Find an instance by its name
     * @param name The name of instance to be found
     * @param classname The cannonical classname of the instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findByName(name: string, classname: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.findByNameWithHttpInfo(name, classname, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     */
    public findBySidesId(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.findBySidesIdWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinks(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Baselink>> {
        return this.findLinksWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksContainers(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<LinkContainer>> {
        return this.findLinksContainersWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksValues(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.findLinksValuesWithHttpInfo(left, right, classname, authenticationkey, value, simpleValue, body, pagesize, currentpage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getConnected(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number,valueId?:string,simpleValue?:string, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.getConnectedWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage,valueId,simpleValue, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
        
            });
    }


       /**
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getConnectedClasses(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number,valueId?:string,simpleValue?:string, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.getConnectedClassesWithHttpInfo(wantedClazzName, id, linkClazzName, authenticationkey, body, pagesize, currentpage,valueId,simpleValue, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
        
            });
    }
    /**
     * 
     * @param id 
     * @param wantedClazzName 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getDisconnected(id: string, wantedClazzName: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number,valueId?:string,simpleValue?:string, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.getDisconnectedWithHttpInfo(id, wantedClazzName, linkClazzName, authenticationkey, body, pagesize, currentpage,valueId,simpleValue, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * import baseclass
     * @summary import baseclass
     * @param className 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public importBaseclass(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.importBaseclassWithHttpInfo(className, authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * 
     * @param leftId 
     * @param rightId 
     * @param operationId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public linkBaseclassTouser(leftId: string, rightId: string, operationId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.linkBaseclassTouserWithHttpInfo(leftId, rightId, operationId, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * Helper class for linking Role and User using a RoleUserContainer class, can be carried out by using the Generic createBaselink call
     * @summary Link Role and User
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public linkroleuser(authenticationkey?: string, body?: RoleUserContainer, extraHttpRequestParams?: any): Observable<RoleToUser> {
        return this.linkroleuserWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * returns a list of instances of the type requested
     * @summary Find an instance by its name with wildcard
     * @param classname The canonical classname of the required entity list
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public nameLike(classname: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Array<Baseclass>> {
        return this.nameLikeWithHttpInfo(classname, authenticationkey, body, pagesize, currentpage, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

    /**
     * soft delete baseclass
     * @summary softDelete
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public softDelete(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.softDeleteWithHttpInfo(id, authenticationkey, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * Update an instance of a Baseclass using a BasicContainer instance 
     * @summary Update basic data
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public updateBasicDetails(authenticationkey?: string, body?: BasicContainer, extraHttpRequestParams?: any): Observable<boolean> {
        return this.updateBasicDetailsWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    /**
     * 
     * 
     * @param type 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public countWithHttpInfo(type: string, authenticationkey?: string, body?: FilteringInformationHolder, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/count/${type}'
                    .replace('${' + 'type' + '}', String(type));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'type' is not null or undefined
        if (type === null || type === undefined) {
            throw new Error('Required parameter type was null or undefined when calling count.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

  /**
     * 
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public countConnectedWithHttpInfo(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number,valueId?:string,simpleValue?:string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/countConnected/${wantedClazzName}/${id}/${linkClazzName}'
                    .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling countConnected.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling countConnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling countConnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }
    /**
     * 
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public countDisconnectedWithHttpInfo(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder,
        pagesize?: number, currentpage?: number,valueId?:string,simpleValue?:string, extraHttpRequestParams?: any): Observable<Response> {
       const path = this.basePath + '/baseclass/countDisconnected/${wantedClazzName}/${id}/${linkClazzName}'
                   .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
                   .replace('${' + 'id' + '}', String(id))
                   .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

       let queryParameters = new URLSearchParams();
       let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

       // verify required parameter 'wantedClazzName' is not null or undefined
       if (wantedClazzName === null || wantedClazzName === undefined) {
           throw new Error('Required parameter wantedClazzName was null or undefined when calling countDisconnected.');
       }
       // verify required parameter 'id' is not null or undefined
       if (id === null || id === undefined) {
           throw new Error('Required parameter id was null or undefined when calling countDisconnected.');
       }
       // verify required parameter 'linkClazzName' is not null or undefined
       if (linkClazzName === null || linkClazzName === undefined) {
           throw new Error('Required parameter linkClazzName was null or undefined when calling countDisconnected.');
       }
       if (authenticationkey !== undefined && authenticationkey !== null) {
           headers.set('authenticationkey', String(authenticationkey));
       }

       if (pagesize !== undefined && pagesize !== null) {
           headers.set('pagesize', String(pagesize));
       }

       if (currentpage !== undefined && currentpage !== null) {
           headers.set('currentpage', String(currentpage));
       }
       if (valueId !== undefined && valueId !== null) {
           headers.set('valueId', String(valueId));
       }
       if (simpleValue !== undefined && simpleValue !== null) {
           headers.set('simpleValue', String(simpleValue));
       }


       // to determine the Accept header
       let produces: string[] = [
           'application/json'
       ];

           
       headers.set('Content-Type', 'application/json');

       let requestOptions: RequestOptionsArgs = new RequestOptions({
           method: RequestMethod.Post,
           headers: headers,
           body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
           search: queryParameters,
           withCredentials:this.configuration.withCredentials
       });
       // https://github.com/swagger-api/swagger-codegen/issues/4037
       if (extraHttpRequestParams) {
           requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
       }

       return this.http.request(path, requestOptions);
   }


    /**
     * Create a link
     * Creates a link between two instances in a generic way, provide values of the link
     * @param leftId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param rightId an ID of existing instance, class of which must fit the required class for the supplied Link class
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value The ID of any instance inheriting from FC Baseclass, this effectively creates a triple link
     * @param simpleValue An explicit value of a string that can be part of the link
     * @param check If true, check if the link with these Left, Right and Complex Value values exists, if yes, then it will not be created
     */
    public createBaselinkWithHttpInfo(leftId: string, rightId: string, linkClazzName: string, authenticationkey?: string, value?: string, simpleValue?: string, check?: boolean, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/${leftId}/${linkClazzName}/${rightId}'
                    .replace('${' + 'leftId' + '}', String(leftId))
                    .replace('${' + 'rightId' + '}', String(rightId))
                    .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'leftId' is not null or undefined
        if (leftId === null || leftId === undefined) {
            throw new Error('Required parameter leftId was null or undefined when calling createBaselink.');
        }
        // verify required parameter 'rightId' is not null or undefined
        if (rightId === null || rightId === undefined) {
            throw new Error('Required parameter rightId was null or undefined when calling createBaselink.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling createBaselink.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }

        if (check !== undefined && check !== null) {
            headers.set('check', String(check));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete
     * deletes an entity by id
     * @param id The id of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteByIdWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteById.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * delete
     * deletes an entity by id
     * @param id The id of the instance to be deleted
     * @param className The type of the instance to be deleted
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public deleteById_1WithHttpInfo(id: string, className: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/${class_name}/${id}'
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'class_name' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deleteById_1.');
        }
        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling deleteById_1.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Remove a link
     * Remove an existing link by the ID of its &#39;sides&#39;
     * @param leftId The ID of the left side of the link
     * @param rightId The ID of the right side of the link
     * @param linkClazzName The canonical name of the class of the link, for example: com.flexicore.model.MediaToBundle, in this case the left ID must be of Media class and the RightID must be of a bundle class
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public detachEntitiesWithHttpInfo(leftId: string, rightId: string, linkClazzName: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/${leftId}/${linkClazzName}/${rightId}'
                    .replace('${' + 'leftId' + '}', String(leftId))
                    .replace('${' + 'rightId' + '}', String(rightId))
                    .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'leftId' is not null or undefined
        if (leftId === null || leftId === undefined) {
            throw new Error('Required parameter leftId was null or undefined when calling detachEntities.');
        }
        // verify required parameter 'rightId' is not null or undefined
        if (rightId === null || rightId === undefined) {
            throw new Error('Required parameter rightId was null or undefined when calling detachEntities.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling detachEntities.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * duplicate an entity, shallow by id 
     * duplicate an entity by Id , returns null if not successfully duplicated
     * @param id The ID of the entity required
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public duplicateWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/clone/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling duplicate.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * export baseclass
     * exports to file 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public exportBaseclassWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/exportBaseclass/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling exportBaseclass.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }



    
    /**
     * export baseclass
     * exports to file 
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public setBaseclassTenant( authenticationkey?: string, body?: SetBaseclassTenantRequest,extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/setBaseclassTenant/';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

       
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];
        headers.set('Content-Type', 'application/json');


            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            body:body,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * find entity by id and class
     * Find an entity by Id and type, returns null if not found
     * @param id The ID of the entity required
     * @param classname The canonical classname of the required entity
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findByIdWithHttpInfo(id: string, classname: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/getbyid/${id}/${classname}'
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling findById.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findById.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Find an instance by ID
     * Find an instance of a Baseclass extender by its id, returns an instance of a Baseclass
     * @param ID The id of instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findById_2WithHttpInfo(ID: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/${id}'
                    .replace('${' + 'id' + '}', String(ID));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'ID' is not null or undefined
        if (ID === null || ID === undefined) {
            throw new Error('Required parameter ID was null or undefined when calling findById_2.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Find an instance by its name
     * returns a list of instances of the type requested
     * @param name The name of instance to be found
     * @param classname The cannonical classname of the instance to be found
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public findByNameWithHttpInfo(name: string, classname: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/${name}/${classname}'
                    .replace('${' + 'Name' + '}', String(name))
                    .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error('Required parameter name was null or undefined when calling findByName.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findByName.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     */
    public findBySidesIdWithHttpInfo(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/${left}/${right}/${classname}'
                    .replace('${' + 'left' + '}', String(left))
                    .replace('${' + 'right' + '}', String(right))
                    .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findBySidesId.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findBySidesId.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findBySidesId.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksWithHttpInfo(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/findLinks/${left}/${right}/${classname}'
                    .replace('${' + 'left' + '}', String(left))
                    .replace('${' + 'right' + '}', String(right))
                    .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findLinks.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findLinks.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findLinks.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksContainersWithHttpInfo(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/findLinksContainers/${left}/${right}/${classname}'
                    .replace('${' + 'left' + '}', String(left))
                    .replace('${' + 'right' + '}', String(right))
                    .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findLinksContainers.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findLinksContainers.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findLinksContainers.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param left 
     * @param right 
     * @param classname 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param value 
     * @param simpleValue 
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public findLinksValuesWithHttpInfo(left: string, right: string, classname: string, authenticationkey?: string, value?: string, simpleValue?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/findLinksValues/${left}/${right}/${classname}'
                    .replace('${' + 'left' + '}', String(left))
                    .replace('${' + 'right' + '}', String(right))
                    .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'left' is not null or undefined
        if (left === null || left === undefined) {
            throw new Error('Required parameter left was null or undefined when calling findLinksValues.');
        }
        // verify required parameter 'right' is not null or undefined
        if (right === null || right === undefined) {
            throw new Error('Required parameter right was null or undefined when calling findLinksValues.');
        }
        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling findLinksValues.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (value !== undefined && value !== null) {
            headers.set('value', String(value));
        }

        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }


    public getFilterClassInfo( authenticationkey?: string,  body?: GetClassInfo, extraHttpRequestParams?: any): Observable<ParameterInfo> {
        return this.getFilterClassInfoWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

  
    public getFilterClassInfoWithHttpInfo( authenticationkey?: string,  body?: GetClassInfo, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/getFilterClassInfo';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

     
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

       


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }


    public getClassInfo( authenticationkey?: string,  body?: GetClassInfo, extraHttpRequestParams?: any): Observable<ParameterInfo> {
        return this.getClassInfoWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }


    
    public getExample( authenticationkey?: string,  body?: GetClassInfo, extraHttpRequestParams?: any): Observable<any> {
        return this.getExampleWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {``
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

  
    public getClassInfoWithHttpInfo( authenticationkey?: string,  body?: GetClassInfo, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/getClassInfo';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

     
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

       


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }


    public getExampleWithHttpInfo( authenticationkey?: string,  body?: GetClassInfo, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/getExample';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

     
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

       


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }


    public listInheritingClasses( authenticationkey?: string,  body?: GetClassInfo, extraHttpRequestParams?: any): Observable<PaginationResponse<ClassInfo>> {
        return this.listInheritingClassesWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

  
    public listInheritingClassesWithHttpInfo( authenticationkey?: string,  body?: GetClassInfo, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/listInheritingClasses';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

     
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

       


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    public  listAllBaseclassGeneric<T extends FilteringInformationHolder,E>( authenticationkey?: string,  body?:T, extraHttpRequestParams?: any): Observable<PaginationResponse<E>> {
        return this.listAllBaseclassGenericWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

  
    public listAllBaseclassGenericWithHttpInfo<T extends FilteringInformationHolder>( authenticationkey?: string,  body?: T, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/listAllBaseclassGeneric';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

     
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

       


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }


    public  exportBaseclassGeneric<T extends FilteringInformationHolder>( authenticationkey?: string,  body?:ExportBaseclassGeneric<T>, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.exportBaseclassGenericWithHttpInfo(authenticationkey, body, extraHttpRequestParams)
            .map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return  FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            });
    }

  
    public exportBaseclassGenericWithHttpInfo<T extends FilteringInformationHolder>( authenticationkey?: string,  body?:ExportBaseclassGeneric<T>, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/exportBaseclassGeneric';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

     
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

       


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getConnectedWithHttpInfo(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number,valueId?:string,simpleValue?:string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/connected/${wantedClazzName}/${id}/${linkClazzName}'
                    .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling getConnected.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getConnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling getConnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param wantedClazzName 
     * @param id 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getConnectedClassesWithHttpInfo(wantedClazzName: string, id: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number,valueId?:string,simpleValue?:string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/connectedClasses/${wantedClazzName}/${id}/${linkClazzName}'
                    .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling getConnected.');
        }
        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getConnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling getConnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param wantedClazzName 
     * @param linkClazzName 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public getDisconnectedWithHttpInfo(id: string, wantedClazzName: string, linkClazzName: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number,valueId?:string,simpleValue?:string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/disconnected/${wantedClazzName}/${id}/${linkClazzName}'
                    .replace('${' + 'id' + '}', String(id))
                    .replace('${' + 'wantedClazzName' + '}', String(wantedClazzName))
                    .replace('${' + 'linkClazzName' + '}', String(linkClazzName));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getDisconnected.');
        }
        // verify required parameter 'wantedClazzName' is not null or undefined
        if (wantedClazzName === null || wantedClazzName === undefined) {
            throw new Error('Required parameter wantedClazzName was null or undefined when calling getDisconnected.');
        }
        // verify required parameter 'linkClazzName' is not null or undefined
        if (linkClazzName === null || linkClazzName === undefined) {
            throw new Error('Required parameter linkClazzName was null or undefined when calling getDisconnected.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }
        if (valueId !== undefined && valueId !== null) {
            headers.set('valueId', String(valueId));
        }
        if (simpleValue !== undefined && simpleValue !== null) {
            headers.set('simpleValue', String(simpleValue));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * import baseclass
     * import baseclass
     * @param className 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public importBaseclassWithHttpInfo(className: string, authenticationkey?: string, body?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/importBaseclass/${className}'
                    .replace('${' + 'className' + '}', String(className));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'className' is not null or undefined
        if (className === null || className === undefined) {
            throw new Error('Required parameter className was null or undefined when calling importBaseclass.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param leftId 
     * @param rightId 
     * @param operationId 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public linkBaseclassTouserWithHttpInfo(leftId: string, rightId: string, operationId: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/linkUserToBaseclass/${left_id}/${right_id}/${operation_id}'
                    .replace('${' + 'left_id' + '}', String(leftId))
                    .replace('${' + 'right_id' + '}', String(rightId))
                    .replace('${' + 'operation_id' + '}', String(operationId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'leftId' is not null or undefined
        if (leftId === null || leftId === undefined) {
            throw new Error('Required parameter leftId was null or undefined when calling linkBaseclassTouser.');
        }
        // verify required parameter 'rightId' is not null or undefined
        if (rightId === null || rightId === undefined) {
            throw new Error('Required parameter rightId was null or undefined when calling linkBaseclassTouser.');
        }
        // verify required parameter 'operationId' is not null or undefined
        if (operationId === null || operationId === undefined) {
            throw new Error('Required parameter operationId was null or undefined when calling linkBaseclassTouser.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Link Role and User
     * Helper class for linking Role and User using a RoleUserContainer class, can be carried out by using the Generic createBaselink call
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public linkroleuserWithHttpInfo(authenticationkey?: string, body?: RoleUserContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baselinks/linkroleuser';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * Find an instance by its name with wildcard
     * returns a list of instances of the type requested
     * @param classname The canonical classname of the required entity list
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body filtering information
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentpage The current page or -1 for full list
     */
    public nameLikeWithHttpInfo(classname: string, authenticationkey?: string, body?: FilteringInformationHolder, pagesize?: number, currentpage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/like/name/${classname}'
                    .replace('${' + 'classname' + '}', String(classname));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'classname' is not null or undefined
        if (classname === null || classname === undefined) {
            throw new Error('Required parameter classname was null or undefined when calling nameLike.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentpage !== undefined && currentpage !== null) {
            headers.set('currentpage', String(currentpage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * softDelete
     * soft delete baseclass
     * @param id 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     */
    public softDeleteWithHttpInfo(id: string, authenticationkey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass/softDelete/${id}'
                    .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling softDelete.');
        }
        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];

            
        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

   
    /**
     * Update basic data
     * Update an instance of a Baseclass using a BasicContainer instance 
     * @param authenticationkey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public updateBasicDetailsWithHttpInfo(authenticationkey?: string, body?: BasicContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/baseclass';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationkey !== undefined && authenticationkey !== null) {
            headers.set('authenticationkey', String(authenticationkey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];

            
        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials:this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    public genericSoftDelete(body?: BasicDelete, authenticationKey?: string): Observable<BasicDeleteResponse> {
        let preparedBody = {
            entries: [body]
        };
        let headers = this.defaultHeaders;
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers.set('Content-Type', httpContentTypeSelected);
        }
        
        const indexOfFlexicore = this.basePath.indexOf('FlexiCore/rest');
        if (indexOfFlexicore > -1) {
            this.basePath = this.basePath.slice(0, indexOfFlexicore);
        }

        return this.http.delete(`${this.basePath}/generic/softDelete`,
            {
                body: preparedBody,
                withCredentials: this.configuration.withCredentials,
                headers: headers
            }
        ).map(o => FlexiCoreDecycle.retrocycle(o));
    }

}
