/**
 * REST API for Flexicore filtered by your access rights
 * Flexicore REST API
 *
 * OpenAPI spec version: V1.1.0
 * Contact: avishaybennatan@gmail.com
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from '@angular/core'; import { FlexiCoreDecycle } from './flexiCoreDecycle';
import { Http, Headers, URLSearchParams } from '@angular/http';
import { RequestMethod, RequestOptions, RequestOptionsArgs } from '@angular/http';
import { Response } from '@angular/http';

import { Observable } from 'rxjs';
import { map } from 'rxjs/operators';

import { BasicContainer } from '../model/basicContainer';
import { DeviceContainer } from '../model/deviceContainer';
import { DeviceToFileUpdate } from '../model/deviceToFileUpdate';
import { DeviceToSoftwareUpdate } from '../model/deviceToSoftwareUpdate';
import { ExportRequestContainer } from '../model/exportRequestContainer';
import { FileResource } from '../model/fileResource';
import { FileUpdate } from '../model/fileUpdate';
import { FileUpdateContainer } from '../model/fileUpdateContainer';
import { FilteringInformationHolder } from '../model/filteringInformationHolder';
import { Job } from '../model/job';
import { LinkContainer } from '../model/linkContainer';
import { LogRequest } from '../model/logRequest';
import { SettingsContainer } from '../model/settingsContainer';
import { Software } from '../model/software';
import { SoftwareUpdateContainer } from '../model/softwareUpdateContainer';
import { UpdateBundle } from '../model/updateBundle';
import { UpdateableDevice } from '../model/updateableDevice';
import { UpdateableDeviceCompatiableContainer } from '../model/updateableDeviceCompatiableContainer';
import { UpdatesDownloadRequestContainer } from '../model/updatesDownloadRequestContainer';

import { BASE_PATH } from '../variables';
import { Configuration } from '../configuration';


@Injectable()
export class SoftwareUpdateService {

    protected basePath = 'https://192.168.0.41:8080/FlexiCore/rest';
    public defaultHeaders: Headers = new Headers();
    public configuration: Configuration = new Configuration();

    constructor(protected http: Http, @Optional() @Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * 
     * Extends object by coping non-existing properties.
     * @param objA object to be extended
     * @param objB source object
     */
    private extendObj<T1, T2>(objA: T1, objB: T2) {
        for (let key in objB) {
            if (objB.hasOwnProperty(key)) {
                (objA as any)[key] = (objB as any)[key];
            }
        }
        return <T1 & T2>objA;
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (let consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    /**
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public activateDevice(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.activateDeviceWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param deviceId 
     * @param fileResourceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public addDeviceInitiatedLog(deviceId: string, fileResourceId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.addDeviceInitiatedLogWithHttpInfo(deviceId, fileResourceId, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param deviceId 
     * @param updateFileId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param locationOnDevice 
     * @param keepOriginal 
     * @param name 
     * @param shouldExtract 
     * @param deleteAfterExtract 
     * @param interval 
     * @param startMilis 
     */
    public attachDeviceToFileUpdate(deviceId: string, updateFileId: string, authenticationKey?: string, locationOnDevice?: string, keepOriginal?: boolean, name?: string, shouldExtract?: boolean, deleteAfterExtract?: boolean, interval?: number, startMilis?: number, extraHttpRequestParams?: any): Observable<DeviceToFileUpdate> {
        return this.attachDeviceToFileUpdateWithHttpInfo(deviceId, updateFileId, authenticationKey, locationOnDevice, keepOriginal, name, shouldExtract, deleteAfterExtract, interval, startMilis, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param lat 
     * @param lon 
     * @param serialNumber 
     */
    public checkDeviceActivatedAndUpdateLocation(id: string, authenticationKey?: string, lat?: number, lon?: number, serialNumber?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.checkDeviceActivatedAndUpdateLocationWithHttpInfo(id, authenticationKey, lat, lon, serialNumber, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public checkFoLogRequests(deviceId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Array<LogRequest>> {
        return this.checkFoLogRequestsWithHttpInfo(deviceId, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public clearDeviceUpdateLinks(deviceId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.clearDeviceUpdateLinksWithHttpInfo(deviceId, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public clearFileUpdates(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.clearFileUpdatesWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public clearLogs(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.clearLogsWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param linkId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public clearUpdateLink(linkId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.clearUpdateLinkWithHttpInfo(linkId, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param fileUpdateId 
     * @param linkId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted 
     */
    public closeFetchRequest(fileUpdateId: string, linkId: string, authenticationKey?: string, dateCompleted?: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.closeFetchRequestWithHttpInfo(fileUpdateId, linkId, authenticationKey, dateCompleted, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param linkId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted 
     */
    public closeRequest(linkId: string, authenticationKey?: string, dateCompleted?: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.closeRequestWithHttpInfo(linkId, authenticationKey, dateCompleted, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param linkId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public confirmRestart(linkId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.confirmRestartWithHttpInfo(linkId, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param bundleName 
     */
    public createUpdateBundle(authenticationKey?: string, body?: Array<string>, bundleName?: string, extraHttpRequestParams?: any): Observable<UpdateBundle> {
        return this.createUpdateBundleWithHttpInfo(authenticationKey, body, bundleName, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public deactivateDevice(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.deactivateDeviceWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public exportUpdates(authenticationKey?: string, body?: ExportRequestContainer, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.exportUpdatesWithHttpInfo(authenticationKey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public fixDevicesDevices(authenticationKey?: string, extraHttpRequestParams?: any): Observable<Job> {
        return this.fixDevicesDevicesWithHttpInfo(authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public fixDevicesName(authenticationKey?: string, extraHttpRequestParams?: any): Observable<Job> {
        return this.fixDevicesNameWithHttpInfo(authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public fixDuplicateMacs(authenticationKey?: string, extraHttpRequestParams?: any): Observable<Job> {
        return this.fixDuplicateMacsWithHttpInfo(authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public getDuplicatedMacs(authenticationKey?: string, extraHttpRequestParams?: any): Observable<Array<string>> {
        return this.getDuplicatedMacsWithHttpInfo(authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param locationOnDevice 
     * @param keepOriginal 
     * @param name 
     * @param generationRequest 
     * @param interval 
     * @param startMilis 
     */
    public getFileFromDeviceRequest(deviceId: string, authenticationKey?: string, locationOnDevice?: string, keepOriginal?: boolean, name?: string, generationRequest?: string, interval?: number, startMilis?: number, extraHttpRequestParams?: any): Observable<DeviceToFileUpdate> {
        return this.getFileFromDeviceRequestWithHttpInfo(deviceId, authenticationKey, locationOnDevice, keepOriginal, name, generationRequest, interval, startMilis, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param mac 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted 
     */
    public getMinimumCheckInterval(mac: string, authenticationKey?: string, dateCompleted?: number, extraHttpRequestParams?: any): Observable<number> {
        return this.getMinimumCheckIntervalWithHttpInfo(mac, authenticationKey, dateCompleted, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param mac 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public getPendingFileUpdates(mac: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Array<FileUpdateContainer>> {
        return this.getPendingFileUpdatesWithHttpInfo(mac, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param startingDate 
     */
    public getPeriodicFilesForFileUpdate(id: string, authenticationKey?: string, startingDate?: Date, extraHttpRequestParams?: any): Observable<Array<BasicContainer>> {
        return this.getPeriodicFilesForFileUpdateWithHttpInfo(id, authenticationKey, startingDate, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param startingDate 
     */
    public getPeriodicFilesForLogRequests(id: string, authenticationKey?: string, startingDate?: Date, extraHttpRequestParams?: any): Observable<Array<BasicContainer>> {
        return this.getPeriodicFilesForLogRequestsWithHttpInfo(id, authenticationKey, startingDate, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param mac 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public getRequiredUpdates(mac: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Array<SoftwareUpdateContainer>> {
        return this.getRequiredUpdatesWithHttpInfo(mac, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public getSoftwareToRestart(deviceId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Array<LinkContainer>> {
        return this.getSoftwareToRestartWithHttpInfo(deviceId, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listDeviceFileUpdates(deviceId: string, authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Array<FileUpdateContainer>> {
        return this.listDeviceFileUpdatesWithHttpInfo(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listDeviceInstalledSoftwares(deviceId: string, authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Array<Software>> {
        return this.listDeviceInstalledSoftwaresWithHttpInfo(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listDevicePendingInstallSoftwares(deviceId: string, authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Array<SoftwareUpdateContainer>> {
        return this.listDevicePendingInstallSoftwaresWithHttpInfo(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listDevicePendingLogRequests(deviceId: string, authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Array<LogRequest>> {
        return this.listDevicePendingLogRequestsWithHttpInfo(deviceId, authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public listDeviceSettings(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Array<SettingsContainer>> {
        return this.listDeviceSettingsWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param serial 
     * @param mac 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listDevices(authenticationKey?: string, body?: FilteringInformationHolder, serial?: string, mac?: string, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Array<UpdateableDevice>> {
        return this.listDevicesWithHttpInfo(authenticationKey, body, serial, mac, pagesize, currentPage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listFileUpdates(authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Array<FileUpdate>> {
        return this.listFileUpdatesWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listSoftwares(authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Array<Software>> {
        return this.listSoftwaresWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listUpdateBundle(authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Array<UpdateBundle>> {
        return this.listUpdateBundleWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listUpdateFiles(authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Array<FileUpdate>> {
        return this.listUpdateFilesWithHttpInfo(authenticationKey, body, pagesize, currentPage, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public massDownload(authenticationKey?: string, body?: UpdatesDownloadRequestContainer, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.massDownloadWithHttpInfo(authenticationKey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public prepareFileResourceBundle(authenticationKey?: string, body?: Array<string>, extraHttpRequestParams?: any): Observable<FileResource> {
        return this.prepareFileResourceBundleWithHttpInfo(authenticationKey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param mac 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param serialNumber 
     * @param body 
     */
    public register(mac: string, authenticationKey?: string, serialNumber?: string, body?: DeviceContainer, extraHttpRequestParams?: any): Observable<UpdateableDeviceCompatiableContainer> {
        return this.registerWithHttpInfo(mac, authenticationKey, serialNumber, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param filter 
     * @param level 
     * @param interval 
     * @param startMilis 
     */
    public requestLog(deviceId: string, authenticationKey?: string, filter?: string, level?: string, interval?: number, startMilis?: number, extraHttpRequestParams?: any): Observable<LogRequest> {
        return this.requestLogWithHttpInfo(deviceId, authenticationKey, filter, level, interval, startMilis, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param deviceId 
     * @param softwareId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public setSoftwareToRestart(deviceId: string, softwareId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.setSoftwareToRestartWithHttpInfo(deviceId, softwareId, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param serialNumber 
     */
    public updateDeviceStatusAndGetIsActivate(id: string, authenticationKey?: string, body?: DeviceContainer, serialNumber?: string, extraHttpRequestParams?: any): Observable<boolean> {
        return this.updateDeviceStatusAndGetIsActivateWithHttpInfo(id, authenticationKey, body, serialNumber, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param requestId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted 
     */
    public updateFileUpdateStarted(requestId: string, authenticationKey?: string, dateCompleted?: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateFileUpdateStartedWithHttpInfo(requestId, authenticationKey, dateCompleted, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public updateMultipleSoftware(deviceId: string, authenticationKey?: string, body?: Array<string>, extraHttpRequestParams?: any): Observable<Array<DeviceToSoftwareUpdate>> {
        return this.updateMultipleSoftwareWithHttpInfo(deviceId, authenticationKey, body, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param requestId 
     * @param fileResourceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param logDate 
     */
    public updateRequestLogAsCompleted(requestId: string, fileResourceId: string, authenticationKey?: string, logDate?: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateRequestLogAsCompletedWithHttpInfo(requestId, fileResourceId, authenticationKey, logDate, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param requestId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted 
     */
    public updateRequestLogAsGathered(requestId: string, authenticationKey?: string, dateCompleted?: number, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateRequestLogAsGatheredWithHttpInfo(requestId, authenticationKey, dateCompleted, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param softwareId 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateSoftware(softwareId: string, deviceId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<DeviceToSoftwareUpdate> {
        return this.updateSoftwareWithHttpInfo(softwareId, deviceId, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param bundleId 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateSoftwareBundle(bundleId: string, deviceId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Array<DeviceToSoftwareUpdate>> {
        return this.updateSoftwareBundleWithHttpInfo(bundleId, deviceId, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateUpdateCompleted(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateUpdateCompletedWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateUpdateStarted(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateUpdateStartedWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }

    /**
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateUpdateVerified(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<{}> {
        return this.updateUpdateVerifiedWithHttpInfo(id, authenticationKey, extraHttpRequestParams)
            .pipe(map((response: Response) => {
                if (response.status === 204) {
                    return undefined;
                } else {
                    return FlexiCoreDecycle.retrocycle(response.json()) || {};
                }
            }));
    }


    /**
     * 
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public activateDeviceWithHttpInfo(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/activate/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling activateDevice.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param deviceId 
     * @param fileResourceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public addDeviceInitiatedLogWithHttpInfo(deviceId: string, fileResourceId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/addDeviceInitiatedLog/${deviceId}/${fileResourceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId))
            .replace('${' + 'fileResourceId' + '}', String(fileResourceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling addDeviceInitiatedLog.');
        }
        // verify required parameter 'fileResourceId' is not null or undefined
        if (fileResourceId === null || fileResourceId === undefined) {
            throw new Error('Required parameter fileResourceId was null or undefined when calling addDeviceInitiatedLog.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param deviceId 
     * @param updateFileId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param locationOnDevice 
     * @param keepOriginal 
     * @param name 
     * @param shouldExtract 
     * @param deleteAfterExtract 
     * @param interval 
     * @param startMilis 
     */
    public attachDeviceToFileUpdateWithHttpInfo(deviceId: string, updateFileId: string, authenticationKey?: string, locationOnDevice?: string, keepOriginal?: boolean, name?: string, shouldExtract?: boolean, deleteAfterExtract?: boolean, interval?: number, startMilis?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/attachDeviceToFileUpdate/${deviceId}/${updateFileId}'
            .replace('${' + 'deviceId' + '}', String(deviceId))
            .replace('${' + 'updateFileId' + '}', String(updateFileId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling attachDeviceToFileUpdate.');
        }
        // verify required parameter 'updateFileId' is not null or undefined
        if (updateFileId === null || updateFileId === undefined) {
            throw new Error('Required parameter updateFileId was null or undefined when calling attachDeviceToFileUpdate.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (locationOnDevice !== undefined && locationOnDevice !== null) {
            headers.set('locationOnDevice', String(locationOnDevice));
        }

        if (keepOriginal !== undefined && keepOriginal !== null) {
            headers.set('keepOriginal', String(keepOriginal));
        }

        if (name !== undefined && name !== null) {
            headers.set('name', String(name));
        }

        if (shouldExtract !== undefined && shouldExtract !== null) {
            headers.set('shouldExtract', String(shouldExtract));
        }

        if (deleteAfterExtract !== undefined && deleteAfterExtract !== null) {
            headers.set('deleteAfterExtract', String(deleteAfterExtract));
        }

        if (interval !== undefined && interval !== null) {
            headers.set('interval', String(interval));
        }

        if (startMilis !== undefined && startMilis !== null) {
            headers.set('startMilis', String(startMilis));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param lat 
     * @param lon 
     * @param serialNumber 
     */
    public checkDeviceActivatedAndUpdateLocationWithHttpInfo(id: string, authenticationKey?: string, lat?: number, lon?: number, serialNumber?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/checkDeviceActivated/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling checkDeviceActivatedAndUpdateLocation.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (lat !== undefined && lat !== null) {
            headers.set('lat', String(lat));
        }

        if (lon !== undefined && lon !== null) {
            headers.set('lon', String(lon));
        }

        if (serialNumber !== undefined && serialNumber !== null) {
            headers.set('serialNumber', String(serialNumber));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public checkFoLogRequestsWithHttpInfo(deviceId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/checkFoLogRequests/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling checkFoLogRequests.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public clearDeviceUpdateLinksWithHttpInfo(deviceId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/clearDeviceUpdateLinks/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling clearDeviceUpdateLinks.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public clearFileUpdatesWithHttpInfo(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/clearFileUpdates/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling clearFileUpdates.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public clearLogsWithHttpInfo(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/clearLogs/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling clearLogs.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param linkId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public clearUpdateLinkWithHttpInfo(linkId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/clearUpdateLink/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling clearUpdateLink.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Delete,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param fileUpdateId 
     * @param linkId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted 
     */
    public closeFetchRequestWithHttpInfo(fileUpdateId: string, linkId: string, authenticationKey?: string, dateCompleted?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/closeFetchRequest/${linkId}/${fileUpdateId}'
            .replace('${' + 'fileUpdateId' + '}', String(fileUpdateId))
            .replace('${' + 'linkId' + '}', String(linkId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'fileUpdateId' is not null or undefined
        if (fileUpdateId === null || fileUpdateId === undefined) {
            throw new Error('Required parameter fileUpdateId was null or undefined when calling closeFetchRequest.');
        }
        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling closeFetchRequest.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (dateCompleted !== undefined && dateCompleted !== null) {
            headers.set('dateCompleted', String(dateCompleted));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param linkId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted 
     */
    public closeRequestWithHttpInfo(linkId: string, authenticationKey?: string, dateCompleted?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/closeRequest/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling closeRequest.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (dateCompleted !== undefined && dateCompleted !== null) {
            headers.set('dateCompleted', String(dateCompleted));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param linkId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public confirmRestartWithHttpInfo(linkId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/confirmRestart/${linkId}'
            .replace('${' + 'linkId' + '}', String(linkId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'linkId' is not null or undefined
        if (linkId === null || linkId === undefined) {
            throw new Error('Required parameter linkId was null or undefined when calling confirmRestart.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param bundleName 
     */
    public createUpdateBundleWithHttpInfo(authenticationKey?: string, body?: Array<string>, bundleName?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/createUpdateBundle';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (bundleName !== undefined && bundleName !== null) {
            headers.set('bundleName', String(bundleName));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public deactivateDeviceWithHttpInfo(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/deactivate/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling deactivateDevice.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public exportUpdatesWithHttpInfo(authenticationKey?: string, body?: ExportRequestContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/exportUpdates';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public fixDevicesDevicesWithHttpInfo(authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/fixDevicesDevices';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public fixDevicesNameWithHttpInfo(authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/fixDevicesName';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public fixDuplicateMacsWithHttpInfo(authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/fixDuplicateMacs';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public getDuplicatedMacsWithHttpInfo(authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/getDuplicatedMacs';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param locationOnDevice 
     * @param keepOriginal 
     * @param name 
     * @param generationRequest 
     * @param interval 
     * @param startMilis 
     */
    public getFileFromDeviceRequestWithHttpInfo(deviceId: string, authenticationKey?: string, locationOnDevice?: string, keepOriginal?: boolean, name?: string, generationRequest?: string, interval?: number, startMilis?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/getFileFromDeviceRequest/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getFileFromDeviceRequest.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (locationOnDevice !== undefined && locationOnDevice !== null) {
            headers.set('locationOnDevice', String(locationOnDevice));
        }

        if (keepOriginal !== undefined && keepOriginal !== null) {
            headers.set('keepOriginal', String(keepOriginal));
        }

        if (name !== undefined && name !== null) {
            headers.set('name', String(name));
        }

        if (generationRequest !== undefined && generationRequest !== null) {
            headers.set('generationRequest', String(generationRequest));
        }

        if (interval !== undefined && interval !== null) {
            headers.set('interval', String(interval));
        }

        if (startMilis !== undefined && startMilis !== null) {
            headers.set('startMilis', String(startMilis));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param mac 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted 
     */
    public getMinimumCheckIntervalWithHttpInfo(mac: string, authenticationKey?: string, dateCompleted?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/getMinimumCheckInterval/${mac}'
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling getMinimumCheckInterval.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (dateCompleted !== undefined && dateCompleted !== null) {
            headers.set('dateCompleted', String(dateCompleted));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param mac 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public getPendingFileUpdatesWithHttpInfo(mac: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/getPendingFileUpdates/${mac}'
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling getPendingFileUpdates.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param startingDate 
     */
    public getPeriodicFilesForFileUpdateWithHttpInfo(id: string, authenticationKey?: string, startingDate?: Date, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/getPeriodicFilesForFileUpdate/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPeriodicFilesForFileUpdate.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (startingDate !== undefined && startingDate !== null) {
            headers.set('startingDate', String(startingDate));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param startingDate 
     */
    public getPeriodicFilesForLogRequestsWithHttpInfo(id: string, authenticationKey?: string, startingDate?: Date, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/getPeriodicFilesForLogRequests/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling getPeriodicFilesForLogRequests.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (startingDate !== undefined && startingDate !== null) {
            headers.set('startingDate', String(startingDate));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param mac 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public getRequiredUpdatesWithHttpInfo(mac: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/getRequiredUpdates/${mac}'
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling getRequiredUpdates.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public getSoftwareToRestartWithHttpInfo(deviceId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/getSoftwareToRestart/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling getSoftwareToRestart.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listDeviceFileUpdatesWithHttpInfo(deviceId: string, authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/listDeviceFileUpdates/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling listDeviceFileUpdates.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listDeviceInstalledSoftwaresWithHttpInfo(deviceId: string, authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/listDeviceInstalledSoftwares/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling listDeviceInstalledSoftwares.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listDevicePendingInstallSoftwaresWithHttpInfo(deviceId: string, authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/listDevicePendingInstallSoftwares/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling listDevicePendingInstallSoftwares.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listDevicePendingLogRequestsWithHttpInfo(deviceId: string, authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/listDevicePendingLogRequests/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling listDevicePendingLogRequests.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public listDeviceSettingsWithHttpInfo(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/listDeviceSettings/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling listDeviceSettings.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Get,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param serial 
     * @param mac 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listDevicesWithHttpInfo(authenticationKey?: string, body?: FilteringInformationHolder, serial?: string, mac?: string, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/listDevices';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (serial !== undefined && serial !== null) {
            headers.set('serial', String(serial));
        }

        if (mac !== undefined && mac !== null) {
            headers.set('mac', String(mac));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listFileUpdatesWithHttpInfo(authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/listFileUpdates';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listSoftwaresWithHttpInfo(authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/listSoftwares';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listUpdateBundleWithHttpInfo(authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/listBundles';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param pagesize Number of entries to be retrieved per page or -1 for full list
     * @param currentPage The current page or -1 for full list
     */
    public listUpdateFilesWithHttpInfo(authenticationKey?: string, body?: FilteringInformationHolder, pagesize?: number, currentPage?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/listUpdateFiles';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (pagesize !== undefined && pagesize !== null) {
            headers.set('pagesize', String(pagesize));
        }

        if (currentPage !== undefined && currentPage !== null) {
            headers.set('currentPage', String(currentPage));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public massDownloadWithHttpInfo(authenticationKey?: string, body?: UpdatesDownloadRequestContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/massDownload';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public prepareFileResourceBundleWithHttpInfo(authenticationKey?: string, body?: Array<string>, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/prepareFileResourceBundle';

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param mac 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param serialNumber 
     * @param body 
     */
    public registerWithHttpInfo(mac: string, authenticationKey?: string, serialNumber?: string, body?: DeviceContainer, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/register/${mac}'
            .replace('${' + 'mac' + '}', String(mac));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'mac' is not null or undefined
        if (mac === null || mac === undefined) {
            throw new Error('Required parameter mac was null or undefined when calling register.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (serialNumber !== undefined && serialNumber !== null) {
            headers.set('serialNumber', String(serialNumber));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param filter 
     * @param level 
     * @param interval 
     * @param startMilis 
     */
    public requestLogWithHttpInfo(deviceId: string, authenticationKey?: string, filter?: string, level?: string, interval?: number, startMilis?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/requestLog/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling requestLog.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (filter !== undefined && filter !== null) {
            headers.set('filter', String(filter));
        }

        if (level !== undefined && level !== null) {
            headers.set('level', String(level));
        }

        if (interval !== undefined && interval !== null) {
            headers.set('interval', String(interval));
        }

        if (startMilis !== undefined && startMilis !== null) {
            headers.set('startMilis', String(startMilis));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param deviceId 
     * @param softwareId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public setSoftwareToRestartWithHttpInfo(deviceId: string, softwareId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/setSoftwareToRestart/${deviceId}/${softwareId}'
            .replace('${' + 'deviceId' + '}', String(deviceId))
            .replace('${' + 'softwareId' + '}', String(softwareId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling setSoftwareToRestart.');
        }
        // verify required parameter 'softwareId' is not null or undefined
        if (softwareId === null || softwareId === undefined) {
            throw new Error('Required parameter softwareId was null or undefined when calling setSoftwareToRestart.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     * @param serialNumber 
     */
    public updateDeviceStatusAndGetIsActivateWithHttpInfo(id: string, authenticationKey?: string, body?: DeviceContainer, serialNumber?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/updateDeviceStatusAndGetIsActivate/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateDeviceStatusAndGetIsActivate.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (serialNumber !== undefined && serialNumber !== null) {
            headers.set('serialNumber', String(serialNumber));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Post,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param requestId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted 
     */
    public updateFileUpdateStartedWithHttpInfo(requestId: string, authenticationKey?: string, dateCompleted?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/updateFileUpdateStarted/${requestId}'
            .replace('${' + 'requestId' + '}', String(requestId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'requestId' is not null or undefined
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling updateFileUpdateStarted.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (dateCompleted !== undefined && dateCompleted !== null) {
            headers.set('dateCompleted', String(dateCompleted));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param body 
     */
    public updateMultipleSoftwareWithHttpInfo(deviceId: string, authenticationKey?: string, body?: Array<string>, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/updateMultipleSoftware/${deviceId}'
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling updateMultipleSoftware.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        headers.set('Content-Type', 'application/json');

        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            body: body == null ? '' : JSON.stringify(body), // https://github.com/angular/angular/issues/10612
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param requestId 
     * @param fileResourceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param logDate 
     */
    public updateRequestLogAsCompletedWithHttpInfo(requestId: string, fileResourceId: string, authenticationKey?: string, logDate?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/updateRequestLogAsCompleted/${requestId}/${fileResourceId}'
            .replace('${' + 'requestId' + '}', String(requestId))
            .replace('${' + 'fileResourceId' + '}', String(fileResourceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'requestId' is not null or undefined
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling updateRequestLogAsCompleted.');
        }
        // verify required parameter 'fileResourceId' is not null or undefined
        if (fileResourceId === null || fileResourceId === undefined) {
            throw new Error('Required parameter fileResourceId was null or undefined when calling updateRequestLogAsCompleted.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (logDate !== undefined && logDate !== null) {
            headers.set('logDate', String(logDate));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param requestId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     * @param dateCompleted 
     */
    public updateRequestLogAsGatheredWithHttpInfo(requestId: string, authenticationKey?: string, dateCompleted?: number, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/updateRequestLogAsStarted/${requestId}'
            .replace('${' + 'requestId' + '}', String(requestId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'requestId' is not null or undefined
        if (requestId === null || requestId === undefined) {
            throw new Error('Required parameter requestId was null or undefined when calling updateRequestLogAsGathered.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }

        if (dateCompleted !== undefined && dateCompleted !== null) {
            headers.set('dateCompleted', String(dateCompleted));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param softwareId 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateSoftwareWithHttpInfo(softwareId: string, deviceId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/updateSoftware/${softwareId}/${deviceId}'
            .replace('${' + 'softwareId' + '}', String(softwareId))
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'softwareId' is not null or undefined
        if (softwareId === null || softwareId === undefined) {
            throw new Error('Required parameter softwareId was null or undefined when calling updateSoftware.');
        }
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling updateSoftware.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param bundleId 
     * @param deviceId 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateSoftwareBundleWithHttpInfo(bundleId: string, deviceId: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/updateSoftwareBundle/${bundleId}/${deviceId}'
            .replace('${' + 'bundleId' + '}', String(bundleId))
            .replace('${' + 'deviceId' + '}', String(deviceId));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'bundleId' is not null or undefined
        if (bundleId === null || bundleId === undefined) {
            throw new Error('Required parameter bundleId was null or undefined when calling updateSoftwareBundle.');
        }
        // verify required parameter 'deviceId' is not null or undefined
        if (deviceId === null || deviceId === undefined) {
            throw new Error('Required parameter deviceId was null or undefined when calling updateSoftwareBundle.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
            'application/json'
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateUpdateCompletedWithHttpInfo(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/updateUpdateCompleted/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUpdateCompleted.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateUpdateStartedWithHttpInfo(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/updateUpdateStarted/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUpdateStarted.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

    /**
     * 
     * 
     * @param id 
     * @param authenticationKey The AuthenticationKey retrieved when sign-in into the system
     */
    public updateUpdateVerifiedWithHttpInfo(id: string, authenticationKey?: string, extraHttpRequestParams?: any): Observable<Response> {
        const path = this.basePath + '/plugins/softwareUpdate/updateUpdateVerified/${id}'
            .replace('${' + 'id' + '}', String(id));

        let queryParameters = new URLSearchParams();
        let headers = new Headers(this.defaultHeaders.toJSON()); // https://github.com/angular/angular/issues/6845

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
            throw new Error('Required parameter id was null or undefined when calling updateUpdateVerified.');
        }
        if (authenticationKey !== undefined && authenticationKey !== null) {
            headers.set('authenticationKey', String(authenticationKey));
        }


        // to determine the Accept header
        let produces: string[] = [
        ];


        let requestOptions: RequestOptionsArgs = new RequestOptions({
            method: RequestMethod.Put,
            headers: headers,
            search: queryParameters,
            withCredentials: this.configuration.withCredentials
        });
        // https://github.com/swagger-api/swagger-codegen/issues/4037
        if (extraHttpRequestParams) {
            requestOptions = (<any>Object).assign(requestOptions, extraHttpRequestParams);
        }

        return this.http.request(path, requestOptions);
    }

}
